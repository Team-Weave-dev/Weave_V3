import { useState, useCallback, useEffect, useMemo } from 'react';
import { v4 as uuidv4 } from 'uuid';
import type { TodoTask, TodoSection, TodoPriority, ViewMode } from '../types';
import type { TodoTask as DashboardTodoTask } from '@/types/dashboard';
import type { TodoSection as StorageTodoSection } from '@/lib/storage/types/entities/todo-section';
import {
  VIEW_MODE_KEY,
  DEFAULT_PRIORITY
} from '../constants';
import { generateInitialData } from '../constants/mock-data';
import { notifyCalendarDataChanged, addCalendarDataChangedListener } from '@/lib/calendar-integration/events';
import {
  getTodoTasks,
  toTask
} from '@/lib/mock/tasks';
import { taskService } from '@/lib/storage';
import { todoSectionService } from '@/lib/storage';

// ============================================================================
// Type Conversion: Widget TodoTask â†” Dashboard TodoTask
// ============================================================================

/**
 * Convert Dashboard TodoTask to Widget TodoTask
 */
function dashboardToWidgetTask(dashboardTask: DashboardTodoTask): TodoTask {
  return {
    id: dashboardTask.id,
    title: dashboardTask.title,
    completed: dashboardTask.completed,
    priority: dashboardTask.priority,
    depth: dashboardTask.depth,
    children: dashboardTask.children?.map(dashboardToWidgetTask),
    sectionId: dashboardTask.sectionId,
    parentId: dashboardTask.parentId,
    order: dashboardTask.order,
    isExpanded: dashboardTask.isExpanded,
    createdAt: dashboardTask.createdAt, // Dashboard has required createdAt
    completedAt: dashboardTask.completedAt,
    dueDate: dashboardTask.dueDate,
  };
}

/**
 * Convert Widget TodoTask to Dashboard TodoTask
 */
function widgetToDashboardTask(widgetTask: TodoTask): DashboardTodoTask {
  return {
    id: widgetTask.id,
    title: widgetTask.title,
    completed: widgetTask.completed,
    priority: widgetTask.priority,
    depth: widgetTask.depth,
    children: widgetTask.children?.map(widgetToDashboardTask),
    sectionId: widgetTask.sectionId,
    parentId: widgetTask.parentId,
    order: widgetTask.order,
    isExpanded: widgetTask.isExpanded,
    createdAt: widgetTask.createdAt || new Date(), // Ensure createdAt is always set
    completedAt: widgetTask.completedAt,
    dueDate: widgetTask.dueDate,
  };
}

// ============================================================================
// Type Conversion: Widget TodoSection â†” Storage TodoSection
// ============================================================================

/**
 * Convert Storage TodoSection to Widget TodoSection
 */
function storageToWidgetSection(storageSection: StorageTodoSection): TodoSection {
  return {
    id: storageSection.id,
    name: storageSection.name,
    order: storageSection.orderIndex,
    isExpanded: storageSection.isExpanded
  };
}

/**
 * Convert Widget TodoSection to Storage TodoSection Create payload
 * (id, userId, createdAt, updatedAt will be generated by service)
 */
function _widgetToStorageSection(
  widgetSection: TodoSection,
  userId: string
): Omit<StorageTodoSection, 'id' | 'createdAt' | 'updatedAt'> {
  return {
    userId,
    name: widgetSection.name,
    orderIndex: widgetSection.order,
    isExpanded: widgetSection.isExpanded
  };
}

export function useTodoState(props?: {
  tasks?: TodoTask[],
  onTaskAdd?: (task: TodoTask) => void,
  onTaskToggle?: (id: string) => void,
  onTaskDelete?: (id: string) => void,
  onTaskUpdate?: (id: string, updates: Partial<TodoTask>) => void
}) {
  const { tasks: propsTasks, onTaskAdd, onTaskToggle, onTaskDelete, onTaskUpdate } = props || {};

  // Load initial data from Storage API or generate mock data
  const loadInitialData = useCallback(async () => {
    // SSR check - return initial data on server
    if (typeof window === 'undefined') {
      console.log('SSR detected, returning initial data');
      return generateInitialData();
    }

    try {
      // Storage APIì—ì„œ tasks ë¡œë“œ (Dashboard TodoTask[])
      const savedDashboardTasks = await getTodoTasks();

      // Dashboard TodoTask[] â†’ Widget TodoTask[] ë³€í™˜
      const savedTasks = savedDashboardTasks.map(dashboardToWidgetTask);

      // Storage APIì—ì„œ sections ë¡œë“œ (RLSë¡œ ìë™ í•„í„°ë§ë¨)
      const storageSections = await todoSectionService.getAll();

      // Storage TodoSection[] â†’ Widget TodoSection[] ë³€í™˜
      const savedSections = storageSections.map(storageToWidgetSection);

      // Tasksë‚˜ Sections ì¤‘ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ ì €ì¥ëœ ë°ì´í„° ì‚¬ìš©
      if ((savedTasks && savedTasks.length > 0) || (savedSections && savedSections.length > 0)) {
        // Use saved data if available
        return {
          tasks: savedTasks || [],
          sections: savedSections || []
        };
      } else {
        // Generate initial data only if both are empty
        return generateInitialData();
      }
    } catch (error) {
      console.error('Failed to load todo data from Storage API:', error);
      return generateInitialData();
    }
  }, []);

  // Get initial data - prefer props over Storage API
  const getInitialData = useCallback(async () => {
    // If props tasks are provided and not empty, use them
    if (propsTasks && propsTasks.length > 0) {
      const sectionsFromTasks: TodoSection[] = Array.from(new Set(propsTasks.map(t => t.sectionId)))
        .filter((id): id is string => Boolean(id)) // Type guard to filter out undefined
        .map((sectionId, index) => ({
          id: sectionId,
          name: sectionId,
          order: index,
          isExpanded: true
        }));
      return { tasks: propsTasks, sections: sectionsFromTasks };
    }

    // Otherwise, load from Storage API or generate initial data
    return await loadInitialData();
  }, [propsTasks, loadInitialData]);

  // React ìƒíƒœ ì§ì ‘ ê´€ë¦¬ (useLocalStorage ëŒ€ì‹  useState ì‚¬ìš©)
  const [localTasks, setLocalTasksState] = useState<TodoTask[]>([]);
  const [sectionsRaw, setSectionsRaw] = useState<TodoSection[]>([]);
  const [isInitialized, setIsInitialized] = useState(false);

  // Initial data ë¹„ë™ê¸° ë¡œë“œ ë° Supabase ë³€ê²½ì‚¬í•­ ê°ì§€
  useEffect(() => {
    let isMounted = true;

    const initializeData = async () => {
      const data = await getInitialData();
      if (isMounted) {
        setLocalTasksState(data.tasks);
        setSectionsRaw(data.sections);
        setIsInitialized(true);
      }
    };

    initializeData();

    return () => {
      isMounted = false;
    };
  }, []); // í•œ ë²ˆë§Œ ì‹¤í–‰

  // Supabase ë™ê¸°í™”: ìº˜ë¦°ë”ë‚˜ ë‹¤ë¥¸ ìœ„ì ¯ì—ì„œ ë³€ê²½í•œ ë‚´ìš©ì„ ì‹¤ì‹œê°„ ë°˜ì˜
  useEffect(() => {
    if (!isInitialized) return;

    const reloadFromStorage = async () => {
      try {
        // Storage APIì—ì„œ ìµœì‹  ë°ì´í„° ë‹¤ì‹œ ë¡œë“œ
        const updatedTasks = await getTodoTasks();
        const storageSections = await todoSectionService.getAll();

        if (Array.isArray(updatedTasks)) {
          // Dashboard TodoTask[] â†’ Widget TodoTask[] ë³€í™˜
          const widgetTasks = updatedTasks.map(dashboardToWidgetTask);
          setLocalTasksState(widgetTasks);
        }

        if (Array.isArray(storageSections) && storageSections.length > 0) {
          const widgetSections = storageSections.map(storageToWidgetSection);
          setSectionsRaw(widgetSections);
        }
      } catch (error) {
        console.error('Failed to reload todo data from Storage:', error);
      }
    };

    // ìº˜ë¦°ë” ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (ë‹¤ë¥¸ ìœ„ì ¯ì—ì„œì˜ ë³€ê²½ì‚¬í•­ ê°ì§€)
    const unsubscribe = addCalendarDataChangedListener((event) => {
      const { source, changeType: _changeType } = event.detail;

      // íˆ¬ë‘ ì†ŒìŠ¤ì˜ ì´ë²¤íŠ¸ë§Œ ì²˜ë¦¬
      if (source === 'todo') {
        reloadFromStorage();
      }
    });

    // storage ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (ë‹¤ë¥¸ íƒ­/ìœˆë„ìš°ì—ì„œì˜ ë³€ê²½ì‚¬í•­ ê°ì§€)
    window.addEventListener('storage', reloadFromStorage);

    return () => {
      unsubscribe();
      window.removeEventListener('storage', reloadFromStorage);
    };
  }, [isInitialized]); // isInitializedê°€ trueê°€ ëœ í›„ì—ë§Œ ì‹¤í–‰

  // ============================================================================
  // Storage ë™ê¸°í™” í—¬í¼ í•¨ìˆ˜
  // ============================================================================

  /**
   * ë‹¨ì¼ íƒœìŠ¤í¬ë¥¼ Storageì— ë™ê¸°í™”
   * @param task - ë™ê¸°í™”í•  íƒœìŠ¤í¬ (Widget íƒ€ì…, DELETE ì‹œì—ëŠ” idë§Œ ìˆì–´ë„ ë¨)
   * @param operation - ìˆ˜í–‰í•  ì‘ì—… ('create' | 'update' | 'delete')
   * @param skipLog - í™œë™ ë¡œê·¸ ìƒì„± ê±´ë„ˆë›°ê¸° (ë‚´ë¶€ ì—…ë°ì´íŠ¸ìš©)
   * @returns ì„±ê³µ ì—¬ë¶€
   */
  const syncTaskToStorage = useCallback(async (
    task: TodoTask,
    operation: 'create' | 'update' | 'delete',
    skipLog = false
  ): Promise<boolean> => {
    try {
      if (operation === 'delete') {
        // DELETEëŠ” IDë§Œ í•„ìš” - íƒ€ì… ë³€í™˜ ì—†ì´ ì§ì ‘ ì‚­ì œ
        await taskService.delete(task.id);
        return true;
      }

      // CREATE/UPDATEëŠ” ì „ì²´ Task ì—”í‹°í‹° í•„ìš”
      const dashboardTask = widgetToDashboardTask(task);
      const taskEntity = toTask(dashboardTask);

      if (operation === 'create') {
        await taskService.create(taskEntity);
      } else {
        await taskService.update(task.id, taskEntity, skipLog);
      }
      return true;
    } catch (error) {
      console.error(`Failed to ${operation} task in Storage:`, error);
      return false;
    }
  }, []);

  /**
   * React Stateë§Œ ì—…ë°ì´íŠ¸ (Storage ë™ê¸°í™” ì—†ìŒ)
   * Storage ë™ê¸°í™”ëŠ” ê° í•¸ë“¤ëŸ¬ì—ì„œ syncTaskToStorageë¥¼ ì§ì ‘ í˜¸ì¶œ
   */
  const setLocalTasks = useCallback((tasks: TodoTask[] | ((prev: TodoTask[]) => TodoTask[])) => {
    setLocalTasksState((prevTasks) => {
      const newTasks = typeof tasks === 'function' ? tasks(prevTasks) : tasks;
      return newTasks;
    });
  }, []);

  // sections ì—…ë°ì´íŠ¸ (Storage APIëŠ” ê° í•¸ë“¤ëŸ¬ì—ì„œ ì§ì ‘ í˜¸ì¶œ)
  const setSections = useCallback((sections: TodoSection[] | ((prev: TodoSection[]) => TodoSection[])) => {
    setSectionsRaw((prevSections) => {
      const newSections = typeof sections === 'function' ? sections(prevSections) : sections;
      // Storage APIëŠ” handleAddSection, handleDeleteSection, handleUpdateSectionì—ì„œ ì§ì ‘ í˜¸ì¶œ
      return newSections;
    });
  }, []);

  // Ensure sections is always an array (defensive programming)
  const sections = Array.isArray(sectionsRaw) ? sectionsRaw : [];
  
  // viewModeë„ useStateë¡œ ë³€ê²½
  const [viewMode, setViewModeState] = useState<ViewMode>(() => {
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem(VIEW_MODE_KEY);
      if (saved) {
        try {
          return JSON.parse(saved);
        } catch {}
      }
    }
    return 'section';
  });

  const setViewMode = useCallback((mode: ViewMode) => {
    setViewModeState(mode);
    if (typeof window !== 'undefined') {
      localStorage.setItem(VIEW_MODE_KEY, JSON.stringify(mode));
    }
  }, []);

  // Local UI state
  const [expandedSections, setExpandedSections] = useState<Record<string, boolean>>({});
  const [selectedSectionId, _setSelectedSectionId] = useState<string | null>(null);
  const [editingTaskId, setEditingTaskId] = useState<string | null>(null);
  const [editingTaskTitle, setEditingTaskTitle] = useState('');
  const [editingSectionId, setEditingSectionId] = useState<string | null>(null);
  const [editingSectionTitle, setEditingSectionTitle] = useState('');
  const [isAddingSection, setIsAddingSection] = useState(false);
  const [newSectionTitle, setNewSectionTitle] = useState('');

  // Drag and drop state
  const [draggedTask, setDraggedTask] = useState<TodoTask | null>(null);
  const [dragOverSection, setDragOverSection] = useState<string | null>(null);

  // Initialize expanded sections on mount
  useEffect(() => {
    const initialExpanded: Record<string, boolean> = {};
    sections.forEach(section => {
      initialExpanded[section.id] = section.isExpanded !== false;
    });
    setExpandedSections(initialExpanded);
  }, [sections]);

  // Task operations
  const handleToggleTask = useCallback((taskId: string) => {
    setLocalTasks(prev => prev.map(task => {
      if (task.id === taskId) {
        const updatedTask = { ...task, completed: !task.completed };

        // Defer callbacks to avoid state update issues
        setTimeout(() => {
          onTaskToggle?.(taskId);

          // ì‹¤ì‹œê°„ ë™ê¸°í™”: ë‹¤ë¥¸ ìœ„ì ¯ë“¤ì—ê²Œ ë³€ê²½ì‚¬í•­ ì•Œë¦¼
          notifyCalendarDataChanged({
            source: 'todo',
            changeType: 'update',
            itemId: taskId,
            timestamp: Date.now(),
          });
        }, 0);

        return updatedTask;
      }
      // Check children
      if (task.children?.length) {
        return {
          ...task,
          children: task.children.map(child =>
            child.id === taskId
              ? { ...child, completed: !child.completed }
              : child
          )
        };
      }
      return task;
    }));
  }, [setLocalTasks, onTaskToggle]);

  const handleDeleteTask = useCallback(async (taskId: string) => {
    // Optimistic update: State ì¦‰ì‹œ ì—…ë°ì´íŠ¸
    const prevTasks = localTasks;
    const taskToDelete = prevTasks.find(t => t.id === taskId) ||
                         prevTasks.flatMap(t => t.children || []).find(c => c.id === taskId);

    if (!taskToDelete) {
      console.error('Task not found:', taskId);
      return;
    }

    // ìì‹ íƒœìŠ¤í¬ ID ìˆ˜ì§‘ (ë¶€ëª¨ ì‚­ì œ ì‹œ ìì‹ë„ í•¨ê»˜ ì‚­ì œ)
    // ì™¸ë˜ í‚¤ ì œì•½ ì¡°ê±´ ë•Œë¬¸ì— ìì‹ì„ ë¨¼ì € ì‚­ì œí•œ í›„ ë¶€ëª¨ë¥¼ ì‚­ì œí•´ì•¼ í•¨
    const childrenToDelete = taskToDelete.children?.map(c => c.id) || [];
    const allTasksToDelete = [...childrenToDelete, taskId]; // ìì‹ ë¨¼ì €, ë¶€ëª¨ ë‚˜ì¤‘

    // UI ì¦‰ì‹œ ì—…ë°ì´íŠ¸
    setLocalTasks(prev =>
      prev
        .filter(task => !allTasksToDelete.includes(task.id))
        .map(task => ({
          ...task,
          children: task.children?.filter(child => !allTasksToDelete.includes(child.id))
        }))
    );

    // Storage ë™ê¸°í™” - ì‚­ì œí•  ëª¨ë“  íƒœìŠ¤í¬ ì²˜ë¦¬
    let deleteSuccess = true;
    for (const deleteId of allTasksToDelete) {
      const success = await syncTaskToStorage({ id: deleteId } as TodoTask, 'delete');
      if (!success) {
        deleteSuccess = false;
        break;
      }
    }

    if (!deleteSuccess) {
      // ì‹¤íŒ¨ ì‹œ ë¡¤ë°±
      setLocalTasks(prevTasks);
      console.error('Failed to delete tasks, rolled back');
      return;
    }

    // ë‹¤ë¥¸ ìœ„ì ¯ì— ì•Œë¦¼
    setTimeout(() => {
      onTaskDelete?.(taskId);
      notifyCalendarDataChanged({
        source: 'todo',
        changeType: 'delete',
        itemId: taskId,
        timestamp: Date.now(),
      });
    }, 0);
  }, [localTasks, setLocalTasks, syncTaskToStorage, onTaskDelete]);

  const handleAddTask = useCallback(async (title: string, sectionId?: string, parentId?: string, priority?: TodoPriority, dueDate?: Date) => {
    // Ensure localTasks is an array
    const tasks = Array.isArray(localTasks) ? localTasks : [];

    // ì„¹ì…˜ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ì„¹ì…˜ ìë™ ìƒì„±
    let targetSectionId = sectionId;
    if (sections.length === 0) {
      const defaultSection: TodoSection = {
        id: 'default',
        name: 'ğŸ“Œ ë¯¸êµ¬ë¶„',
        order: 0,
        isExpanded: true
      };
      setSections([defaultSection]);
      targetSectionId = 'default';
    } else if (!targetSectionId) {
      targetSectionId = sections[0]?.id || 'default';
    }

    const newTask: TodoTask = {
      id: uuidv4(),
      title,
      completed: false,
      priority: priority || DEFAULT_PRIORITY,
      depth: parentId ? 1 : 0,
      children: [],
      sectionId: targetSectionId,
      parentId,
      order: tasks.filter(t => t.sectionId === targetSectionId && !t.parentId).length,
      isExpanded: false,
      createdAt: new Date(),
      dueDate,
    };

    // Optimistic update: State ì¦‰ì‹œ ì—…ë°ì´íŠ¸
    const prevTasks = localTasks;
    setLocalTasks(prev => {
      if (parentId) {
        return prev.map(task =>
          task.id === parentId
            ? { ...task, children: [...(task.children || []), newTask], isExpanded: true }
            : task
        );
      }
      return [...prev, newTask];
    });

    // Storage ë™ê¸°í™”
    const success = await syncTaskToStorage(newTask, 'create');

    if (!success) {
      // ì‹¤íŒ¨ ì‹œ ë¡¤ë°±
      setLocalTasks(prevTasks);
      console.error('Failed to add task, rolled back');
      return;
    }

    // ìì‹ íƒœìŠ¤í¬ì¸ ê²½ìš°: ë¶€ëª¨ì˜ subtasks ë°°ì—´ ì—…ë°ì´íŠ¸
    // skipLog = trueë¡œ ì„¤ì •í•˜ì—¬ í™œë™ ë¡œê·¸ ìƒì„± ë°©ì§€ (ë‚´ë¶€ ì—…ë°ì´íŠ¸)
    if (parentId) {
      const parent = prevTasks.find(t => t.id === parentId);
      if (parent) {
        const updatedParent = {
          ...parent,
          children: [...(parent.children || []), newTask]
        };
        await syncTaskToStorage(updatedParent, 'update', true); // skipLog = true
      }
    }

    // ë‹¤ë¥¸ ìœ„ì ¯ì— ì•Œë¦¼
    setTimeout(() => {
      onTaskAdd?.(newTask);
      notifyCalendarDataChanged({
        source: 'todo',
        changeType: 'add',
        itemId: newTask.id,
        timestamp: Date.now(),
      });
    }, 0);
  }, [localTasks, sections, setSections, setLocalTasks, syncTaskToStorage, onTaskAdd]);

  const handleUpdateTask = useCallback(async (taskId: string, updates: Partial<TodoTask>) => {
    // Optimistic update: State ì¦‰ì‹œ ì—…ë°ì´íŠ¸
    const prevTasks = localTasks;
    let updatedTask: TodoTask | undefined;

    setLocalTasks(prev =>
      prev.map(task => {
        if (task.id === taskId) {
          updatedTask = { ...task, ...updates };
          return updatedTask;
        }
        // Check children
        if (task.children?.length) {
          const hasChildUpdate = task.children.some(child => child.id === taskId);
          if (hasChildUpdate) {
            return {
              ...task,
              children: task.children.map(child => {
                if (child.id === taskId) {
                  updatedTask = { ...child, ...updates };
                  return updatedTask;
                }
                return child;
              })
            };
          }
        }
        return task;
      })
    );

    // Storage ë™ê¸°í™”
    if (updatedTask) {
      const success = await syncTaskToStorage(updatedTask, 'update');

      if (!success) {
        // ì‹¤íŒ¨ ì‹œ ë¡¤ë°±
        setLocalTasks(prevTasks);
        console.error('Failed to update task, rolled back');
        return;
      }
    }

    // ë‹¤ë¥¸ ìœ„ì ¯ì— ì•Œë¦¼
    setTimeout(() => {
      onTaskUpdate?.(taskId, updates);
      notifyCalendarDataChanged({
        source: 'todo',
        changeType: 'update',
        itemId: taskId,
        timestamp: Date.now(),
      });
    }, 0);
  }, [localTasks, setLocalTasks, syncTaskToStorage, onTaskUpdate]);

  // Section operations
  const handleToggleSection = useCallback((sectionId: string) => {
    setExpandedSections(prev => ({
      ...prev,
      [sectionId]: !prev[sectionId]
    }));
  }, []);

  const handleAddSection = useCallback(async (name: string) => {
    // 1. Storage APIì— ë¨¼ì € ì„¹ì…˜ ìƒì„±
    try {
      // NOTE: Supabase RLSê°€ í˜„ì¬ ì¸ì¦ëœ ì‚¬ìš©ìì˜ user_idë¥¼ ìë™ìœ¼ë¡œ ì ìš©
      // í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì „ë‹¬í•˜ëŠ” userIdëŠ” RLS ì •ì±…ì— ì˜í•´ ë¬´ì‹œë¨
      const userId = 'current-user'; // RLSì—ì„œ ì‹¤ì œ auth.uid()ë¡œ ëŒ€ì²´ë¨
      const storagePayload = {
        userId,
        name,
        orderIndex: sections.length,
        isExpanded: true
      };

      // todoSectionService.createë¥¼ í˜¸ì¶œí•˜ì—¬ Storageì— ì €ì¥í•˜ê³  ì‹¤ì œ ìƒì„±ëœ ì„¹ì…˜ ë°›ê¸°
      const createdSection = await todoSectionService.create(storagePayload);

      // 2. Storageì—ì„œ ìƒì„±ëœ ì‹¤ì œ IDë¥¼ ê°€ì§„ Widget TodoSectionìœ¼ë¡œ ë³€í™˜
      const newWidgetSection = storageToWidgetSection(createdSection);

      // 3. React ìƒíƒœ ì—…ë°ì´íŠ¸ (Storage ID ì‚¬ìš©)
      setSections(prev => [...prev, newWidgetSection]);
    } catch (error) {
      console.error('Failed to add section to Storage API:', error);
      // ì—ëŸ¬ ë°œìƒ ì‹œì—ëŠ” ì„¹ì…˜ì´ ì¶”ê°€ë˜ì§€ ì•ŠìŒ (ìë™ ë¡¤ë°±)
    }
  }, [sections, setSections]);

  const handleDeleteSection = useCallback(async (sectionId: string) => {
    // 1. React ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸ (optimistic update)
    setSections(prev => prev.filter(s => s.id !== sectionId));
    setLocalTasks(prev => prev.filter(t => t.sectionId !== sectionId));

    // 2. Storage APIì—ì„œ ë¹„ë™ê¸° ì‚­ì œ
    try {
      await todoSectionService.delete(sectionId);
    } catch (error) {
      console.error('Failed to delete section from Storage API:', error);
      // ì—ëŸ¬ ë°œìƒ ì‹œì—ëŠ” ì´ë¯¸ UIê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìœ¼ë¯€ë¡œ,
      // ë‹¤ìŒ ë¡œë“œ ì‹œ Storageì™€ ë™ê¸°í™”ë  ê²ƒì„
    }
  }, [setSections, setLocalTasks]);

  const handleUpdateSection = useCallback(async (sectionId: string, name: string) => {
    // 1. React ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸ (optimistic update)
    setSections(prev => prev.map(section =>
      section.id === sectionId ? { ...section, name } : section
    ));

    // 2. Storage APIì— ë¹„ë™ê¸° ì—…ë°ì´íŠ¸
    try {
      await todoSectionService.update(sectionId, { name });
    } catch (error) {
      console.error('Failed to update section in Storage API:', error);
      // ì—ëŸ¬ ë°œìƒ ì‹œì—ëŠ” ì´ë¯¸ UIê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìœ¼ë¯€ë¡œ,
      // ë‹¤ìŒ ë¡œë“œ ì‹œ Storageì™€ ë™ê¸°í™”ë  ê²ƒì„
    }
  }, [setSections]);

  // Drag and drop handlers
  const handleDragStart = useCallback((e: React.DragEvent, task: TodoTask) => {
    setDraggedTask(task);
    e.dataTransfer.effectAllowed = 'move';

    // ìº˜ë¦°ë” ìœ„ì ¯ê³¼ì˜ ìƒí˜¸ì‘ìš©ì„ ìœ„í•´ task ë°ì´í„°ë¥¼ dataTransferì— ì €ì¥
    // HTML5 drag and drop APIë¥¼ ì‚¬ìš©í•˜ì—¬ ìœ„ì ¯ ê°„ ë“œë˜ê·¸ ì§€ì›
    const taskData = {
      type: 'todo-task',
      task: {
        id: task.id,
        title: task.title,
        dueDate: task.dueDate,
        priority: task.priority,
        completed: task.completed
      }
    };
    e.dataTransfer.setData('application/json', JSON.stringify(taskData));
    e.dataTransfer.setData('text/plain', task.title); // í´ë°±ìš©
  }, []);

  const handleDragEnd = useCallback(() => {
    setDraggedTask(null);
    setDragOverSection(null);
  }, []);

  const handleDragOver = useCallback((e: React.DragEvent, sectionId: string) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    setDragOverSection(sectionId);
  }, []);

  const handleDrop = useCallback(async (e: React.DragEvent, targetSectionId: string) => {
    e.preventDefault();

    if (!draggedTask) {
      setDraggedTask(null);
      setDragOverSection(null);
      return;
    }

    // ì„¹ì…˜ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ì„¹ì…˜ ìë™ ìƒì„±
    if (sections.length === 0) {
      const defaultSection: TodoSection = {
        id: 'default',
        name: 'ğŸ“Œ ë¯¸êµ¬ë¶„',
        order: 0,
        isExpanded: true
      };
      setSections([defaultSection]);
    }

    // ë‚ ì§œ ë·°ì—ì„œ ë“œë¡­í•œ ê²½ìš° 'date-' ì ‘ë‘ì‚¬ ì œê±°
    let actualSectionId = targetSectionId;
    if (targetSectionId.startsWith('date-')) {
      // ë‚ ì§œ ë·°ì—ì„œëŠ” ì²« ë²ˆì§¸ ì„¹ì…˜ìœ¼ë¡œ ì´ë™í•˜ê±°ë‚˜ 'default' ì„¹ì…˜ìœ¼ë¡œ ì´ë™
      actualSectionId = sections.length > 0 ? sections[0].id : 'default';
    }

    // ë“œë˜ê·¸í•œ ì‘ì—…ì„ ìƒˆë¡œìš´ ì„¹ì…˜ìœ¼ë¡œ ì´ë™
    if (draggedTask.sectionId !== actualSectionId) {
      // React state ì—…ë°ì´íŠ¸ ë° Storage ë™ê¸°í™”
      setLocalTasks(prev => {
        // ë¨¼ì € í•˜ìœ„ ì‘ì—…ë“¤ë„ í•¨ê»˜ ì´ë™
        const moveTaskWithChildren = (tasks: TodoTask[]): TodoTask[] => {
          return tasks.map(task => {
            if (task.id === draggedTask.id) {
              const movedTask = { ...task, sectionId: actualSectionId };
              // Storage ë™ê¸°í™” (ë¹„ë™ê¸°, skipLog = trueë¡œ ë‚´ë¶€ ì—…ë°ì´íŠ¸)
              syncTaskToStorage(movedTask, 'update', true).catch(err => {
                console.error('Failed to sync task section change to Storage:', err);
              });
              return movedTask;
            }
            // ë¶€ëª¨ê°€ ì´ë™í•˜ëŠ” ê²½ìš° ìì‹ë“¤ë„ í•¨ê»˜ ì´ë™
            if (task.parentId === draggedTask.id) {
              const movedChild = { ...task, sectionId: actualSectionId };
              // ìì‹ íƒœìŠ¤í¬ë„ Storage ë™ê¸°í™”
              syncTaskToStorage(movedChild, 'update', true).catch(err => {
                console.error('Failed to sync child task section change to Storage:', err);
              });
              return movedChild;
            }
            // ìì‹ ì‘ì—…ë“¤ í™•ì¸
            if (task.children && task.children.length > 0) {
              return {
                ...task,
                children: task.children.map(child => {
                  if (child.id === draggedTask.id || child.parentId === draggedTask.id) {
                    const movedChild = { ...child, sectionId: actualSectionId };
                    // ìì‹ íƒœìŠ¤í¬ë„ Storage ë™ê¸°í™”
                    syncTaskToStorage(movedChild, 'update', true).catch(err => {
                      console.error('Failed to sync nested child task section change to Storage:', err);
                    });
                    return movedChild;
                  }
                  return child;
                })
              };
            }
            return task;
          });
        };

        return moveTaskWithChildren(prev);
      });
    }

    setDraggedTask(null);
    setDragOverSection(null);
  }, [draggedTask, sections, setSections, setLocalTasks, syncTaskToStorage]);


  // Date groups for date view
  const dateGroups = useMemo(() => {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const thisWeek = new Date(today);
    thisWeek.setDate(thisWeek.getDate() + 7);

    // Ensure localTasks is an array
    const tasks = Array.isArray(localTasks) ? localTasks : [];

    return {
      today: tasks.filter(t => {
        if (!t.dueDate) return false;
        const due = new Date(t.dueDate);
        due.setHours(0, 0, 0, 0);
        return due.getTime() === today.getTime();
      }),
      tomorrow: tasks.filter(t => {
        if (!t.dueDate) return false;
        const due = new Date(t.dueDate);
        due.setHours(0, 0, 0, 0);
        return due.getTime() === tomorrow.getTime();
      }),
      thisWeek: tasks.filter(t => {
        if (!t.dueDate) return false;
        const due = new Date(t.dueDate);
        due.setHours(0, 0, 0, 0);
        return due > tomorrow && due <= thisWeek;
      }),
      overdue: tasks.filter(t => {
        if (!t.dueDate) return false;
        const due = new Date(t.dueDate);
        due.setHours(0, 0, 0, 0);
        return due < today;
      })
    };
  }, [localTasks]);

  return {
    // State
    localTasks,
    sections,
    viewMode,
    expandedSections,
    selectedSectionId,
    editingTaskId,
    editingTaskTitle,
    editingSectionId,
    editingSectionTitle,
    draggedTask,
    dragOverSection,
    isAddingSection,
    newSectionTitle,
    dateGroups,
    
    // Task handlers
    handleToggleTask,
    handleDeleteTask,
    handleAddTask,
    handleUpdateTask,
    
    // Section handlers
    handleToggleSection,
    handleAddSection,
    handleDeleteSection,
    handleUpdateSection,
    
    // Drag handlers
    handleDragStart,
    handleDragEnd,
    handleDragOver,
    handleDrop,
    
    // State setters
    setEditingTaskId,
    setEditingTaskTitle,
    setEditingSectionId,
    setEditingSectionTitle,
    setIsAddingSection,
    setNewSectionTitle,
    setViewMode
  };
}