import { useState, useCallback, useEffect, useMemo, useRef } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { useLocalStorage } from './useLocalStorage';
import { useDragAndDrop } from './useDragAndDrop';
import type { TodoTask, TodoSection, TodoPriority, ViewMode } from '../types';
import type { TodoTask as DashboardTodoTask } from '@/types/dashboard';
import type { TodoSection as StorageTodoSection } from '@/lib/storage/types/entities/todo-section';
import {
  STORAGE_KEY,
  SECTIONS_KEY,
  VIEW_MODE_KEY,
  DEFAULT_PRIORITY
} from '../constants';
import { generateInitialData } from '../constants/mock-data';
import { notifyCalendarDataChanged, addCalendarDataChangedListener } from '@/lib/calendar-integration/events';
import {
  getTodoTasks,
  addTodoTask,
  updateTodoTask,
  deleteTodoTask,
  saveTodoTasks
} from '@/lib/mock/tasks';
import { todoSectionService } from '@/lib/storage';

// ============================================================================
// Type Conversion: Widget TodoTask ‚Üî Dashboard TodoTask
// ============================================================================

/**
 * Convert Dashboard TodoTask to Widget TodoTask
 */
function dashboardToWidgetTask(dashboardTask: DashboardTodoTask): TodoTask {
  return {
    id: dashboardTask.id,
    title: dashboardTask.title,
    completed: dashboardTask.completed,
    priority: dashboardTask.priority,
    depth: dashboardTask.depth,
    children: dashboardTask.children?.map(dashboardToWidgetTask),
    sectionId: dashboardTask.sectionId,
    parentId: dashboardTask.parentId,
    order: dashboardTask.order,
    isExpanded: dashboardTask.isExpanded,
    createdAt: dashboardTask.createdAt, // Dashboard has required createdAt
    completedAt: dashboardTask.completedAt,
    dueDate: dashboardTask.dueDate,
  };
}

/**
 * Convert Widget TodoTask to Dashboard TodoTask
 */
function widgetToDashboardTask(widgetTask: TodoTask): DashboardTodoTask {
  return {
    id: widgetTask.id,
    title: widgetTask.title,
    completed: widgetTask.completed,
    priority: widgetTask.priority,
    depth: widgetTask.depth,
    children: widgetTask.children?.map(widgetToDashboardTask),
    sectionId: widgetTask.sectionId,
    parentId: widgetTask.parentId,
    order: widgetTask.order,
    isExpanded: widgetTask.isExpanded,
    createdAt: widgetTask.createdAt || new Date(), // Ensure createdAt is always set
    completedAt: widgetTask.completedAt,
    dueDate: widgetTask.dueDate,
  };
}

// ============================================================================
// Type Conversion: Widget TodoSection ‚Üî Storage TodoSection
// ============================================================================

/**
 * Convert Storage TodoSection to Widget TodoSection
 */
function storageToWidgetSection(storageSection: StorageTodoSection): TodoSection {
  return {
    id: storageSection.id,
    name: storageSection.name,
    order: storageSection.orderIndex,
    isExpanded: storageSection.isExpanded
  };
}

/**
 * Convert Widget TodoSection to Storage TodoSection Create payload
 * (id, userId, createdAt, updatedAt will be generated by service)
 */
function widgetToStorageSection(
  widgetSection: TodoSection,
  userId: string
): Omit<StorageTodoSection, 'id' | 'createdAt' | 'updatedAt'> {
  return {
    userId,
    name: widgetSection.name,
    orderIndex: widgetSection.order,
    isExpanded: widgetSection.isExpanded
  };
}

export function useTodoState(props?: {
  tasks?: TodoTask[],
  onTaskAdd?: (task: TodoTask) => void,
  onTaskToggle?: (id: string) => void,
  onTaskDelete?: (id: string) => void,
  onTaskUpdate?: (id: string, updates: Partial<TodoTask>) => void
}) {
  const { tasks: propsTasks, onTaskAdd, onTaskToggle, onTaskDelete, onTaskUpdate } = props || {};

  // TODO: Replace with actual user ID from authentication
  // For now, use a default userId for development
  const getCurrentUserId = (): string => {
    // In production, this should come from authentication context
    // For now, use a default test user
    return 'default-user';
  };

  // Load initial data from Storage API or generate mock data
  const loadInitialData = useCallback(async () => {
    // SSR check - return initial data on server
    if (typeof window === 'undefined') {
      console.log('SSR detected, returning initial data');
      return generateInitialData();
    }

    try {
      // Storage APIÏóêÏÑú tasks Î°úÎìú (Dashboard TodoTask[])
      const savedDashboardTasks = await getTodoTasks();

      // Dashboard TodoTask[] ‚Üí Widget TodoTask[] Î≥ÄÌôò
      const savedTasks = savedDashboardTasks.map(dashboardToWidgetTask);

      // Storage APIÏóêÏÑú sections Î°úÎìú
      const userId = getCurrentUserId();
      const storageSections = await todoSectionService.getByUserId(userId);

      // Storage TodoSection[] ‚Üí Widget TodoSection[] Î≥ÄÌôò
      const savedSections = storageSections.map(storageToWidgetSection);

      console.log('Storage API savedTasks:', savedTasks);
      console.log('Storage API savedSections:', savedSections);

      if (savedTasks && savedTasks.length > 0 && savedSections && savedSections.length > 0) {
        // Use saved data if available
        console.log('Returning saved data');
        return { tasks: savedTasks, sections: savedSections };
      } else {
        // Generate initial data
        console.log('Generating initial data');
        const initialData = generateInitialData();
        console.log('Generated initial data:', initialData);
        return initialData;
      }
    } catch (error) {
      console.error('Failed to load todo data from Storage API:', error);
      const initialData = generateInitialData();
      console.log('Generated initial data after error:', initialData);
      return initialData;
    }
  }, []);

  // Get initial data - prefer props over Storage API
  const getInitialData = useCallback(async () => {
    // If props tasks are provided and not empty, use them
    if (propsTasks && propsTasks.length > 0) {
      console.log('Using tasks from props:', propsTasks);
      const sectionsFromTasks: TodoSection[] = Array.from(new Set(propsTasks.map(t => t.sectionId)))
        .filter((id): id is string => Boolean(id)) // Type guard to filter out undefined
        .map((sectionId, index) => ({
          id: sectionId,
          name: sectionId,
          order: index,
          isExpanded: true
        }));
      return { tasks: propsTasks, sections: sectionsFromTasks };
    }

    // Otherwise, load from Storage API or generate initial data
    return await loadInitialData();
  }, [propsTasks, loadInitialData]);

  // React ÏÉÅÌÉú ÏßÅÏ†ë Í¥ÄÎ¶¨ (useLocalStorage ÎåÄÏã† useState ÏÇ¨Ïö©)
  const [localTasks, setLocalTasksState] = useState<TodoTask[]>([]);
  const [sectionsRaw, setSectionsRaw] = useState<TodoSection[]>([]);
  const [isInitialized, setIsInitialized] = useState(false);

  // Initial data ÎπÑÎèôÍ∏∞ Î°úÎìú
  useEffect(() => {
    const initializeData = async () => {
      const data = await getInitialData();
      setLocalTasksState(data.tasks);
      setSectionsRaw(data.sections);
      setIsInitialized(true);
    };

    initializeData();
  }, []); // Ìïú Î≤àÎßå Ïã§Ìñâ

  // Storage API ÎèôÍ∏∞ÌôîÎ•º ÏúÑÌïú Ìó¨Ìçº Ìï®Ïàò
  const setLocalTasks = useCallback((tasks: TodoTask[] | ((prev: TodoTask[]) => TodoTask[])) => {
    setLocalTasksState((prevTasks) => {
      const newTasks = typeof tasks === 'function' ? tasks(prevTasks) : tasks;
      // Widget TodoTask[] ‚Üí Dashboard TodoTask[] Î≥ÄÌôò ÌõÑ Storage APIÏóê Ï†ÄÏû• (ÎπÑÎèôÍ∏∞)
      if (typeof window !== 'undefined') {
        const dashboardTasks = newTasks.map(widgetToDashboardTask);
        saveTodoTasks(dashboardTasks).catch((error) => {
          console.error('Failed to save tasks to Storage API:', error);
        });
      }
      return newTasks;
    });
  }, []);

  // sections ÏóÖÎç∞Ïù¥Ìä∏ (Storage APIÎäî Í∞Å Ìï∏Îì§Îü¨ÏóêÏÑú ÏßÅÏ†ë Ìò∏Ï∂ú)
  const setSections = useCallback((sections: TodoSection[] | ((prev: TodoSection[]) => TodoSection[])) => {
    setSectionsRaw((prevSections) => {
      const newSections = typeof sections === 'function' ? sections(prevSections) : sections;
      // Storage APIÎäî handleAddSection, handleDeleteSection, handleUpdateSectionÏóêÏÑú ÏßÅÏ†ë Ìò∏Ï∂ú
      return newSections;
    });
  }, []);

  // Ensure sections is always an array (defensive programming)
  const sections = Array.isArray(sectionsRaw) ? sectionsRaw : [];
  
  // viewModeÎèÑ useStateÎ°ú Î≥ÄÍ≤Ω
  const [viewMode, setViewModeState] = useState<ViewMode>(() => {
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem(VIEW_MODE_KEY);
      if (saved) {
        try {
          return JSON.parse(saved);
        } catch {}
      }
    }
    return 'section';
  });

  const setViewMode = useCallback((mode: ViewMode) => {
    setViewModeState(mode);
    if (typeof window !== 'undefined') {
      localStorage.setItem(VIEW_MODE_KEY, JSON.stringify(mode));
    }
  }, []);

  // Local UI state
  const [expandedSections, setExpandedSections] = useState<Record<string, boolean>>({});
  const [selectedSectionId, setSelectedSectionId] = useState<string | null>(null);
  const [editingTaskId, setEditingTaskId] = useState<string | null>(null);
  const [editingTaskTitle, setEditingTaskTitle] = useState('');
  const [editingSectionId, setEditingSectionId] = useState<string | null>(null);
  const [editingSectionTitle, setEditingSectionTitle] = useState('');
  const [isAddingSection, setIsAddingSection] = useState(false);
  const [newSectionTitle, setNewSectionTitle] = useState('');

  // Drag and drop state
  const [draggedTask, setDraggedTask] = useState<TodoTask | null>(null);
  const [dragOverSection, setDragOverSection] = useState<string | null>(null);

  // Initialize expanded sections on mount
  useEffect(() => {
    const initialExpanded: Record<string, boolean> = {};
    sections.forEach(section => {
      initialExpanded[section.id] = section.isExpanded !== false;
    });
    setExpandedSections(initialExpanded);
  }, [sections]);

  // Task operations
  const handleToggleTask = useCallback((taskId: string) => {
    setLocalTasks(prev => prev.map(task => {
      if (task.id === taskId) {
        const updatedTask = { ...task, completed: !task.completed };
        onTaskToggle?.(taskId);

        // Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî: Îã§Î•∏ ÏúÑÏ†ØÎì§ÏóêÍ≤å Î≥ÄÍ≤ΩÏÇ¨Ìï≠ ÏïåÎ¶º
        notifyCalendarDataChanged({
          source: 'todo',
          changeType: 'update',
          itemId: taskId,
          timestamp: Date.now(),
        });

        return updatedTask;
      }
      // Check children
      if (task.children?.length) {
        return {
          ...task,
          children: task.children.map(child =>
            child.id === taskId
              ? { ...child, completed: !child.completed }
              : child
          )
        };
      }
      return task;
    }));
  }, [setLocalTasks, onTaskToggle]);

  const handleDeleteTask = useCallback((taskId: string) => {
    // ÏûêÍ∏∞ ÏûêÏã†Ïùò ÏÇ≠Ï†ú ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Í∏∞Î°ù (Ïù¥Î≤§Ìä∏ Ï§ëÎ≥µ Î∞©ÏßÄÏö©)
    const deleteTimestamp = Date.now();

    setLocalTasks(prev => {
      const filtered = prev.map(task => {
        if (task.id === taskId) {
          onTaskDelete?.(taskId);

          // Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî: Îã§Î•∏ ÏúÑÏ†ØÎì§ÏóêÍ≤å Î≥ÄÍ≤ΩÏÇ¨Ìï≠ ÏïåÎ¶º
          notifyCalendarDataChanged({
            source: 'todo',
            changeType: 'delete',
            itemId: taskId,
            timestamp: deleteTimestamp,
          });

          return null; // Mark for removal
        }
        // Keep task but filter children
        if (task.children?.length) {
          const filteredChildren = task.children.filter(child => child.id !== taskId);
          if (filteredChildren.length !== task.children.length) {
            // Child was removed, return new task object
            return {
              ...task,
              children: filteredChildren
            };
          }
        }
        return task;
      }).filter((task): task is TodoTask => task !== null);
      return filtered;
    });
  }, [setLocalTasks, onTaskDelete]);

  const handleAddTask = useCallback((title: string, sectionId?: string, parentId?: string, priority?: TodoPriority, dueDate?: Date) => {
    // Ensure localTasks is an array
    const tasks = Array.isArray(localTasks) ? localTasks : [];

    // ÏÑπÏÖòÏù¥ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ ÏÑπÏÖò ÏûêÎèô ÏÉùÏÑ±
    let targetSectionId = sectionId;
    if (sections.length === 0) {
      const defaultSection: TodoSection = {
        id: 'default',
        name: 'üìå ÎØ∏Íµ¨Î∂Ñ', // brand.tsÏùò defaultSection ÌÖçÏä§Ìä∏ÏôÄ ÎèôÏùº
        order: 0,
        isExpanded: true
      };
      setSections([defaultSection]);
      targetSectionId = 'default';
    } else if (!targetSectionId) {
      targetSectionId = sections[0]?.id || 'default';
    }

    const newTask: TodoTask = {
      id: uuidv4(),
      title,
      completed: false,
      priority: priority || DEFAULT_PRIORITY,
      depth: parentId ? 1 : 0,
      children: [],
      sectionId: targetSectionId,
      parentId,
      order: tasks.filter(t => t.sectionId === targetSectionId && !t.parentId).length,
      isExpanded: false,
      createdAt: new Date(),
      dueDate,
    };

    setLocalTasks(prev => {
      if (parentId) {
        return prev.map(task => {
          if (task.id === parentId) {
            return {
              ...task,
              children: [...(task.children || []), newTask],
              isExpanded: true
            };
          }
          return task;
        });
      }
      return [...prev, newTask];
    });

    onTaskAdd?.(newTask);

    // Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî: Îã§Î•∏ ÏúÑÏ†ØÎì§ÏóêÍ≤å Î≥ÄÍ≤ΩÏÇ¨Ìï≠ ÏïåÎ¶º
    notifyCalendarDataChanged({
      source: 'todo',
      changeType: 'add',
      itemId: newTask.id,
      timestamp: Date.now(),
    });
  }, [localTasks, sections, setSections, setLocalTasks, onTaskAdd]);

  const handleUpdateTask = useCallback((taskId: string, updates: Partial<TodoTask>) => {
    console.log('[useTodoState] handleUpdateTask called:', taskId, updates);

    setLocalTasks(prev => {
      console.log('[useTodoState] Previous tasks:', prev);

      const updatedTasks = prev.map(task => {
        if (task.id === taskId) {
          const updatedTask = { ...task, ...updates };
          console.log('[useTodoState] Updated task:', updatedTask);

          // Defer callbacks to avoid state update issues
          setTimeout(() => {
            onTaskUpdate?.(taskId, updates);

            // Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî: Îã§Î•∏ ÏúÑÏ†ØÎì§ÏóêÍ≤å Î≥ÄÍ≤ΩÏÇ¨Ìï≠ ÏïåÎ¶º
            notifyCalendarDataChanged({
              source: 'todo',
              changeType: 'update',
              itemId: taskId,
              timestamp: Date.now(),
            });
          }, 0);

          return updatedTask;
        }
        // Check children
        if (task.children?.length) {
          const hasChildUpdate = task.children.some(child => child.id === taskId);
          if (hasChildUpdate) {
            // ÌïòÏúÑ ÏûëÏóÖ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏóêÎèÑ ÎèôÍ∏∞Ìôî Ïù¥Î≤§Ìä∏ Î∞úÏÉù
            setTimeout(() => {
              onTaskUpdate?.(taskId, updates);
              notifyCalendarDataChanged({
                source: 'todo',
                changeType: 'update',
                itemId: taskId,
                timestamp: Date.now(),
              });
            }, 0);

            return {
              ...task,
              children: task.children.map(child =>
                child.id === taskId ? { ...child, ...updates } : child
              )
            };
          }
        }
        return task;
      });

      console.log('[useTodoState] Updated tasks:', updatedTasks);
      return updatedTasks;
    });
  }, [setLocalTasks, onTaskUpdate]);

  // Section operations
  const handleToggleSection = useCallback((sectionId: string) => {
    setExpandedSections(prev => ({
      ...prev,
      [sectionId]: !prev[sectionId]
    }));
  }, []);

  const handleAddSection = useCallback(async (name: string) => {
    // 1. Widget TodoSection ÏÉùÏÑ±
    const newWidgetSection: TodoSection = {
      id: uuidv4(),
      name,
      order: sections.length,
      isExpanded: true
    };

    // 2. React ÏÉÅÌÉú Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏ (optimistic update)
    setSections(prev => [...prev, newWidgetSection]);

    // 3. Storage APIÏóê ÎπÑÎèôÍ∏∞ Ï†ÄÏû•
    try {
      const userId = getCurrentUserId();
      const storagePayload = widgetToStorageSection(newWidgetSection, userId);

      // todoSectionService.createÎ•º Ìò∏Ï∂úÌïòÏó¨ StorageÏóê Ï†ÄÏû•
      await todoSectionService.create(storagePayload);

      console.log('Section added to Storage API:', newWidgetSection.name);
    } catch (error) {
      console.error('Failed to add section to Storage API:', error);
      // ÏóêÎü¨ Î∞úÏÉù Ïãú React ÏÉÅÌÉú Î°§Î∞±
      setSections(prev => prev.filter(s => s.id !== newWidgetSection.id));
    }
  }, [sections, setSections]);

  const handleDeleteSection = useCallback(async (sectionId: string) => {
    // 1. React ÏÉÅÌÉú Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏ (optimistic update)
    setSections(prev => prev.filter(s => s.id !== sectionId));
    setLocalTasks(prev => prev.filter(t => t.sectionId !== sectionId));

    // 2. Storage APIÏóêÏÑú ÎπÑÎèôÍ∏∞ ÏÇ≠Ï†ú
    try {
      await todoSectionService.delete(sectionId);
      console.log('Section deleted from Storage API:', sectionId);
    } catch (error) {
      console.error('Failed to delete section from Storage API:', error);
      // ÏóêÎü¨ Î∞úÏÉù ÏãúÏóêÎäî Ïù¥ÎØ∏ UIÍ∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏúºÎØÄÎ°ú,
      // Îã§Ïùå Î°úÎìú Ïãú StorageÏôÄ ÎèôÍ∏∞ÌôîÎê† Í≤ÉÏûÑ
    }
  }, [setSections, setLocalTasks]);

  const handleUpdateSection = useCallback(async (sectionId: string, name: string) => {
    // 1. React ÏÉÅÌÉú Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏ (optimistic update)
    setSections(prev => prev.map(section =>
      section.id === sectionId ? { ...section, name } : section
    ));

    // 2. Storage APIÏóê ÎπÑÎèôÍ∏∞ ÏóÖÎç∞Ïù¥Ìä∏
    try {
      await todoSectionService.update(sectionId, { name });
      console.log('Section updated in Storage API:', sectionId, name);
    } catch (error) {
      console.error('Failed to update section in Storage API:', error);
      // ÏóêÎü¨ Î∞úÏÉù ÏãúÏóêÎäî Ïù¥ÎØ∏ UIÍ∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏúºÎØÄÎ°ú,
      // Îã§Ïùå Î°úÎìú Ïãú StorageÏôÄ ÎèôÍ∏∞ÌôîÎê† Í≤ÉÏûÑ
    }
  }, [setSections]);

  // Drag and drop handlers
  const handleDragStart = useCallback((e: React.DragEvent, task: TodoTask) => {
    setDraggedTask(task);
    e.dataTransfer.effectAllowed = 'move';

    // Ï∫òÎ¶∞Îçî ÏúÑÏ†ØÍ≥ºÏùò ÏÉÅÌò∏ÏûëÏö©ÏùÑ ÏúÑÌï¥ task Îç∞Ïù¥ÌÑ∞Î•º dataTransferÏóê Ï†ÄÏû•
    // HTML5 drag and drop APIÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏúÑÏ†Ø Í∞Ñ ÎìúÎûòÍ∑∏ ÏßÄÏõê
    const taskData = {
      type: 'todo-task',
      task: {
        id: task.id,
        title: task.title,
        dueDate: task.dueDate,
        priority: task.priority,
        completed: task.completed
      }
    };
    e.dataTransfer.setData('application/json', JSON.stringify(taskData));
    e.dataTransfer.setData('text/plain', task.title); // Ìè¥Î∞±Ïö©

    console.log('[TodoListWidget] Drag started for task:', task.id, task.title);
  }, []);

  const handleDragEnd = useCallback(() => {
    setDraggedTask(null);
    setDragOverSection(null);
  }, []);

  const handleDragOver = useCallback((e: React.DragEvent, sectionId: string) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    setDragOverSection(sectionId);
  }, []);

  const handleDrop = useCallback((e: React.DragEvent, targetSectionId: string) => {
    e.preventDefault();
    
    if (!draggedTask) {
      setDraggedTask(null);
      setDragOverSection(null);
      return;
    }
    
    // ÏÑπÏÖòÏù¥ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ ÏÑπÏÖò ÏûêÎèô ÏÉùÏÑ±
    if (sections.length === 0) {
      const defaultSection: TodoSection = {
        id: 'default',
        name: 'üìå ÎØ∏Íµ¨Î∂Ñ',
        order: 0,
        isExpanded: true
      };
      setSections([defaultSection]);
    }

    // ÎÇ†Ïßú Î∑∞ÏóêÏÑú ÎìúÎ°≠Ìïú Í≤ΩÏö∞ 'date-' Ï†ëÎëêÏÇ¨ Ï†úÍ±∞
    let actualSectionId = targetSectionId;
    if (targetSectionId.startsWith('date-')) {
      // ÎÇ†Ïßú Î∑∞ÏóêÏÑúÎäî Ï≤´ Î≤àÏß∏ ÏÑπÏÖòÏúºÎ°ú Ïù¥ÎèôÌïòÍ±∞ÎÇò 'default' ÏÑπÏÖòÏúºÎ°ú Ïù¥Îèô
      actualSectionId = sections.length > 0 ? sections[0].id : 'default';
    }
    
    // ÎìúÎûòÍ∑∏Ìïú ÏûëÏóÖÏùÑ ÏÉàÎ°úÏö¥ ÏÑπÏÖòÏúºÎ°ú Ïù¥Îèô
    if (draggedTask.sectionId !== actualSectionId) {
      setLocalTasks(prev => {
        // Î®ºÏ†Ä ÌïòÏúÑ ÏûëÏóÖÎì§ÎèÑ Ìï®Íªò Ïù¥Îèô
        const moveTaskWithChildren = (tasks: TodoTask[]): TodoTask[] => {
          return tasks.map(task => {
            if (task.id === draggedTask.id) {
              return { ...task, sectionId: actualSectionId };
            }
            // Î∂ÄÎ™®Í∞Ä Ïù¥ÎèôÌïòÎäî Í≤ΩÏö∞ ÏûêÏãùÎì§ÎèÑ Ìï®Íªò Ïù¥Îèô
            if (task.parentId === draggedTask.id) {
              return { ...task, sectionId: actualSectionId };
            }
            // ÏûêÏãù ÏûëÏóÖÎì§ ÌôïÏù∏
            if (task.children && task.children.length > 0) {
              return {
                ...task,
                children: task.children.map(child => {
                  if (child.id === draggedTask.id || child.parentId === draggedTask.id) {
                    return { ...child, sectionId: actualSectionId };
                  }
                  return child;
                })
              };
            }
            return task;
          });
        };
        
        return moveTaskWithChildren(prev);
      });
    }
    
    setDraggedTask(null);
    setDragOverSection(null);
  }, [draggedTask, sections, setSections, setLocalTasks]);

  // Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî: Îã§Î•∏ ÏúÑÏ†Ø(Ï∫òÎ¶∞Îçî)ÏóêÏÑúÏùò Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∞êÏßÄ

  useEffect(() => {
    const handleStorageChange = async () => {
      // Storage APIÏóêÏÑú ÏµúÏã† Îç∞Ïù¥ÌÑ∞ Îã§Ïãú Î°úÎìú
      console.log('[TodoListWidget] handleStorageChange called');
      try {
        const updatedTasks = await getTodoTasks();
        console.log('[TodoListWidget] Storage API data:', updatedTasks);

        if (Array.isArray(updatedTasks)) {
          // React ÏÉÅÌÉú ÏßÅÏ†ë ÏóÖÎç∞Ïù¥Ìä∏ (Storage API Ï†ÄÏû• ÏóÜÏù¥)
          console.log('[TodoListWidget] Updating local tasks with fresh data from Storage API:', updatedTasks);
          setLocalTasksState([...updatedTasks]);
          console.log('[TodoListWidget] Local tasks updated successfully');
        }
      } catch (error) {
        console.error('Failed to sync todo data from Storage API:', error);
      }
    };

    const unsubscribe = addCalendarDataChangedListener((event) => {
      const { source, changeType, itemId, timestamp } = event.detail;

      console.log('[TodoListWidget] Received calendarDataChanged event:', event.detail);
      console.log('[TodoListWidget] Event detail breakdown - source:', source, 'changeType:', changeType, 'itemId:', itemId);

      // Ìà¨Îëê ÏÜåÏä§Ïùò Ïù¥Î≤§Ìä∏Îßå Ï≤òÎ¶¨ (Ï∫òÎ¶∞ÎçîÏóêÏÑú Î∞úÏÉùÌïú Ïù¥Î≤§Ìä∏)
      // changeTypeÏùÑ anyÎ°ú Ï∫êÏä§ÌåÖÌïòÏó¨ ÌÉÄÏûÖ Ï≤¥ÌÅ¨ Ïö∞Ìöå (CalendarWidgetÏóêÏÑú 'update'ÏôÄ 'todo-date-update' ÏÇ¨Ïö©)
      if (source === 'todo') {
        console.log('[TodoListWidget] Source is todo, checking changeType...');
        if ((changeType as any) === 'update' || (changeType as any) === 'todo-date-update') {
          console.log('[TodoListWidget] Processing todo update from calendar, itemId:', itemId, 'changeType:', changeType);
          console.log('[TodoListWidget] Calling handleStorageChange...');

          // localStorage Î≥ÄÍ≤ΩÏùÑ Í∞êÏßÄÌïòÏó¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
          handleStorageChange();
        } else {
          console.log('[TodoListWidget] ChangeType not matched. Actual changeType:', changeType);
        }
      } else {
        console.log('[TodoListWidget] Source not matched. Actual source:', source);
      }
    });

    // storage Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä (Îã§Î•∏ ÌÉ≠/ÏúàÎèÑÏö∞ÏóêÏÑúÏùò Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∞êÏßÄ)
    window.addEventListener('storage', handleStorageChange);

    // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú Î¶¨Ïä§ÎÑà Ìï¥Ï†ú
    return () => {
      unsubscribe();
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [setLocalTasks]);

  // Date groups for date view
  const dateGroups = useMemo(() => {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const thisWeek = new Date(today);
    thisWeek.setDate(thisWeek.getDate() + 7);

    // Ensure localTasks is an array
    const tasks = Array.isArray(localTasks) ? localTasks : [];

    return {
      today: tasks.filter(t => {
        if (!t.dueDate) return false;
        const due = new Date(t.dueDate);
        due.setHours(0, 0, 0, 0);
        return due.getTime() === today.getTime();
      }),
      tomorrow: tasks.filter(t => {
        if (!t.dueDate) return false;
        const due = new Date(t.dueDate);
        due.setHours(0, 0, 0, 0);
        return due.getTime() === tomorrow.getTime();
      }),
      thisWeek: tasks.filter(t => {
        if (!t.dueDate) return false;
        const due = new Date(t.dueDate);
        due.setHours(0, 0, 0, 0);
        return due > tomorrow && due <= thisWeek;
      }),
      overdue: tasks.filter(t => {
        if (!t.dueDate) return false;
        const due = new Date(t.dueDate);
        due.setHours(0, 0, 0, 0);
        return due < today;
      })
    };
  }, [localTasks]);

  return {
    // State
    localTasks,
    sections,
    viewMode,
    expandedSections,
    selectedSectionId,
    editingTaskId,
    editingTaskTitle,
    editingSectionId,
    editingSectionTitle,
    draggedTask,
    dragOverSection,
    isAddingSection,
    newSectionTitle,
    dateGroups,
    
    // Task handlers
    handleToggleTask,
    handleDeleteTask,
    handleAddTask,
    handleUpdateTask,
    
    // Section handlers
    handleToggleSection,
    handleAddSection,
    handleDeleteSection,
    handleUpdateSection,
    
    // Drag handlers
    handleDragStart,
    handleDragEnd,
    handleDragOver,
    handleDrop,
    
    // State setters
    setEditingTaskId,
    setEditingTaskTitle,
    setEditingSectionId,
    setEditingSectionTitle,
    setIsAddingSection,
    setNewSectionTitle,
    setViewMode
  };
}