# 🔒 Weave 프로젝트 보안 취약점 분석 보고서

**분석 일자**: 2025-10-15
**분석 범위**: 인증, API, 데이터 보호, RLS 정책, 클라이언트 보안
**기술 스택**: Next.js 15, React 19, Supabase
**전반적 보안 점수**: **6.5/10** (양호, 일부 개선 필요)

---

## 📊 요약

프로젝트는 Supabase RLS 정책과 인증 후 Supabase-only 스토리지 전략을 통해 기본적인 데이터 보호를 잘 구현했으나, 인증 정책과 API 보안에서 개선이 필요한 취약점이 발견되었습니다.

**주요 발견 사항:**
- 🔴 **Critical**: Rate Limiting 부재로 무차별 대입 공격 취약
- 🔴 **Critical**: 프로덕션 환경 로깅으로 민감 정보 노출 위험
- 🟡 **High**: 비밀번호 정책 미흡, 입력 검증 부족, CSRF 보호 불명확, 보안 헤더 미설정
- 🟢 **Positive**: RLS 정책 적절히 구현, Supabase-only 모드로 데이터 보호 양호

**보안 점수 상세:**
- 인증/인가: 6/10 (RLS는 양호, 인증 정책 취약)
- 데이터 보호: 7/10 (Supabase-only 모드로 민감 데이터 보호)
- API 보안: 5/10 (Rate Limiting 부재)
- 전반적 보안: 6.5/10 (양호, 일부 개선 필요)

---

## 🚨 발견된 취약점 (우선순위별)

### 🔴 Critical (긴급) - 즉시 조치 필요

#### 1. Rate Limiting 부재

**위치**:
- `src/app/api/auth/signin/route.ts`
- `src/app/api/auth/signup/route.ts`
- `src/app/api/auth/google/route.ts`
- 모든 API 엔드포인트

**문제점**:
- 모든 인증 API에 속도 제한이 없음
- 무차별 대입 공격(brute force) 취약
- 계정 열거 공격(account enumeration) 가능
- DoS 공격 위험
- 봇이 무제한으로 API 호출 가능

**영향**:
- 비밀번호 무차별 대입으로 계정 탈취 가능
- 서버 리소스 고갈로 서비스 중단 가능
- 비용 증가 (Supabase, Vercel 사용량 급증)

**권장 조치**:

```typescript
// 방법 1: Vercel Edge Middleware + Upstash Redis (권장)
// npm install @upstash/ratelimit @upstash/redis

// src/lib/ratelimit.ts
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

export const authRatelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(5, '1 m'), // 1분에 5회
  analytics: true,
  prefix: 'ratelimit:auth',
})

export const apiRatelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(100, '1 m'), // 1분에 100회
  analytics: true,
  prefix: 'ratelimit:api',
})

// src/app/api/auth/signin/route.ts
import { authRatelimit } from '@/lib/ratelimit'

export async function POST(request: Request) {
  // IP 기반 Rate Limiting
  const ip = request.headers.get('x-forwarded-for') ?? 'unknown'
  const { success, limit, remaining, reset } = await authRatelimit.limit(ip)

  if (!success) {
    return NextResponse.json(
      {
        error: '요청이 너무 많습니다. 잠시 후 다시 시도해주세요.',
        retryAfter: Math.ceil((reset - Date.now()) / 1000),
      },
      {
        status: 429,
        headers: {
          'X-RateLimit-Limit': limit.toString(),
          'X-RateLimit-Remaining': remaining.toString(),
          'X-RateLimit-Reset': reset.toString(),
        }
      }
    )
  }

  // 기존 로그인 로직...
}
```

```typescript
// 방법 2: 계정 기반 추가 제한 (IP + 계정 이중 보호)
// src/lib/ratelimit.ts

export async function checkAuthRateLimit(
  ip: string,
  email?: string
): Promise<{ success: boolean; error?: string }> {
  // IP 기반 제한
  const ipResult = await authRatelimit.limit(`ip:${ip}`)
  if (!ipResult.success) {
    return {
      success: false,
      error: `IP 제한: ${Math.ceil((ipResult.reset - Date.now()) / 1000)}초 후 재시도`
    }
  }

  // 이메일 기반 제한 (로그인 실패 시)
  if (email) {
    const emailRatelimit = new Ratelimit({
      redis: Redis.fromEnv(),
      limiter: Ratelimit.slidingWindow(3, '5 m'), // 5분에 3회 실패 허용
      prefix: 'ratelimit:email',
    })

    const emailResult = await emailRatelimit.limit(`email:${email}`)
    if (!emailResult.success) {
      return {
        success: false,
        error: `계정 보호: ${Math.ceil((emailResult.reset - Date.now()) / 1000)}초 후 재시도`
      }
    }
  }

  return { success: true }
}

// 사용
const rateLimit = await checkAuthRateLimit(ip, email)
if (!rateLimit.success) {
  return NextResponse.json({ error: rateLimit.error }, { status: 429 })
}
```

```typescript
// 방법 3: 점진적 지연 (Exponential Backoff)
// src/lib/auth/failureTracking.ts

const failureMap = new Map<string, { count: number; lastAttempt: number }>()

export function getLoginDelay(identifier: string): number {
  const record = failureMap.get(identifier)
  if (!record) return 0

  // 실패 횟수에 따라 지연 시간 증가
  const delays = [0, 1000, 2000, 5000, 10000, 30000] // ms
  return delays[Math.min(record.count, delays.length - 1)]
}

export function recordFailure(identifier: string) {
  const record = failureMap.get(identifier) || { count: 0, lastAttempt: 0 }
  failureMap.set(identifier, {
    count: record.count + 1,
    lastAttempt: Date.now(),
  })
}

export function resetFailures(identifier: string) {
  failureMap.delete(identifier)
}

// 사용
const delay = getLoginDelay(email)
if (delay > 0) {
  await new Promise(resolve => setTimeout(resolve, delay))
}
```

---

#### 2. 프로덕션 환경 로깅

**위치**:
- `src/app/api/auth/google/route.ts:5-7`

**문제점**:

```typescript
console.log('🔵 [GOOGLE OAUTH] Starting Google OAuth flow...')
console.log('🔵 [ENV CHECK] NEXT_PUBLIC_SITE_URL:', process.env.NEXT_PUBLIC_SITE_URL)
console.log('🔵 [ENV CHECK] All NEXT_PUBLIC_ vars:', Object.keys(process.env).filter(k => k.startsWith('NEXT_PUBLIC_')))
```

- 프로덕션에서 환경 변수가 로그로 출력됨
- 로그 수집 시스템(Vercel Logs, Datadog 등)에서 민감 정보 노출 위험
- process.env 객체 전체를 로깅하면 예상치 못한 비밀 노출 가능
- 디버깅 코드가 프로덕션에 남아있음

**영향**:
- 환경 변수 노출로 시스템 구성 정보 유출
- API 키, 데이터베이스 URL 등 민감 정보 노출 가능
- 로그 접근 권한이 있는 모든 사람에게 정보 노출

**권장 조치**:

```typescript
// 방법 1: 환경별 로깅 분기
// src/app/api/auth/google/route.ts

export async function GET() {
  // 개발 환경에서만 로깅
  if (process.env.NODE_ENV === 'development') {
    console.log('[DEV] Starting Google OAuth flow')
    console.log('[DEV] NEXT_PUBLIC_SITE_URL:', process.env.NEXT_PUBLIC_SITE_URL)
  }

  // 프로덕션에서는 구조화된 로깅만
  if (process.env.NODE_ENV === 'production') {
    // 민감 정보 제외하고 이벤트만 기록
    console.log(JSON.stringify({
      event: 'oauth_start',
      provider: 'google',
      timestamp: new Date().toISOString(),
    }))
  }

  // ... OAuth 로직
}
```

```typescript
// 방법 2: 구조화된 로깅 라이브러리 사용 (권장)
// npm install pino pino-pretty

// src/lib/logger.ts
import pino from 'pino'

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  // 프로덕션에서는 JSON 포맷
  ...((process.env.NODE_ENV === 'production')
    ? {}
    : { transport: { target: 'pino-pretty' } }
  ),
  // 민감 정보 자동 제거
  redact: {
    paths: [
      'req.headers.authorization',
      'req.headers.cookie',
      'password',
      'token',
      '*.password',
      '*.token',
    ],
    remove: true,
  },
})

export default logger

// 사용
import logger from '@/lib/logger'

logger.info({ event: 'oauth_start', provider: 'google' })
logger.error({ err, event: 'oauth_error' }, 'OAuth failed')
```

```typescript
// 방법 3: 환경 변수 화이트리스트
// src/lib/logger.ts

const SAFE_ENV_VARS = [
  'NODE_ENV',
  'NEXT_PUBLIC_APP_NAME',
  'NEXT_PUBLIC_APP_URL',
  // 민감하지 않은 public 변수만 포함
]

export function logSafeEnvVars() {
  const safeEnv = Object.entries(process.env)
    .filter(([key]) => SAFE_ENV_VARS.includes(key))
    .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {})

  console.log('[ENV]', safeEnv)
}
```

---

### 🟡 High (높음) - 단기 조치 필요

#### 3. 비밀번호 정책 미흡

**위치**:
- `src/app/api/auth/signup/route.ts:16-21`

**문제점**:

```typescript
if (password.length < 6) {
  return NextResponse.json(
    { error: '비밀번호는 최소 6자 이상이어야 합니다.' },
    { status: 400 }
  )
}
```

- 최소 6자만 요구 (NIST 권장 최소 8자, 일반적으로 10자 이상 권장)
- 복잡도 요구사항 없음 (대소문자, 숫자, 특수문자 혼합)
- 일반적인 비밀번호 차단 없음 (password123, 123456 등)
- 연속된 문자, 반복 문자 검증 없음

**영향**:
- 약한 비밀번호로 계정 생성 가능
- 무차별 대입 공격 성공 확률 증가
- 사전 공격(dictionary attack) 취약

**권장 조치**:

```typescript
// 방법 1: Zod를 사용한 강력한 비밀번호 검증 (권장)
// npm install zod

// src/lib/validation/password.ts
import { z } from 'zod'

// 일반적인 비밀번호 목록 (실제로는 더 큰 리스트 사용)
const COMMON_PASSWORDS = [
  'password', 'password123', '12345678', 'qwerty123',
  'abc123', '111111', '123456', '123456789',
  'password1', 'qwerty', 'admin', 'letmein',
]

export const passwordSchema = z.string()
  .min(10, '비밀번호는 최소 10자 이상이어야 합니다.')
  .max(128, '비밀번호는 128자를 초과할 수 없습니다.')
  .regex(/[A-Z]/, '대문자를 1개 이상 포함해야 합니다.')
  .regex(/[a-z]/, '소문자를 1개 이상 포함해야 합니다.')
  .regex(/[0-9]/, '숫자를 1개 이상 포함해야 합니다.')
  .regex(/[^A-Za-z0-9]/, '특수문자를 1개 이상 포함해야 합니다.')
  .refine((pwd) => !COMMON_PASSWORDS.includes(pwd.toLowerCase()), {
    message: '일반적인 비밀번호는 사용할 수 없습니다.'
  })
  .refine((pwd) => !/(.)\1{2,}/.test(pwd), {
    message: '동일한 문자를 3번 이상 연속 사용할 수 없습니다.'
  })
  .refine((pwd) => !/012|123|234|345|456|567|678|789|890/.test(pwd), {
    message: '연속된 숫자를 사용할 수 없습니다.'
  })

// src/app/api/auth/signup/route.ts
import { passwordSchema } from '@/lib/validation/password'

export async function POST(request: Request) {
  const { email, password, name } = await request.json()

  // 비밀번호 검증
  const result = passwordSchema.safeParse(password)
  if (!result.success) {
    return NextResponse.json(
      { error: result.error.issues[0].message },
      { status: 400 }
    )
  }

  // ... 기존 로직
}
```

```typescript
// 방법 2: Have I Been Pwned API로 유출된 비밀번호 확인
// npm install @jdanford/pwned

// src/lib/validation/password.ts
import { pwned } from '@jdanford/pwned'

export async function checkPwnedPassword(password: string): Promise<boolean> {
  try {
    const count = await pwned(password)
    return count > 0 // 유출된 적이 있으면 true
  } catch (error) {
    // API 오류 시 검증 통과 (서비스 중단 방지)
    console.error('Pwned API check failed:', error)
    return false
  }
}

// 회원가입 시 추가 검증
const isPwned = await checkPwnedPassword(password)
if (isPwned) {
  return NextResponse.json(
    { error: '이 비밀번호는 과거 데이터 유출에서 발견되었습니다. 다른 비밀번호를 사용해주세요.' },
    { status: 400 }
  )
}
```

```typescript
// 방법 3: 비밀번호 강도 점수 표시 (클라이언트)
// npm install zxcvbn

// src/components/auth/PasswordStrengthMeter.tsx
import zxcvbn from 'zxcvbn'

export function PasswordStrengthMeter({ password }: { password: string }) {
  const result = zxcvbn(password)
  const score = result.score // 0-4

  const colors = ['red', 'orange', 'yellow', 'lightgreen', 'green']
  const labels = ['매우 약함', '약함', '보통', '강함', '매우 강함']

  return (
    <div>
      <div className="strength-bar" style={{ backgroundColor: colors[score] }} />
      <p>비밀번호 강도: {labels[score]}</p>
      {result.feedback.warning && <p className="warning">{result.feedback.warning}</p>}
      {result.feedback.suggestions.map((s, i) => (
        <p key={i} className="suggestion">{s}</p>
      ))}
    </div>
  )
}
```

---

#### 4. 입력 검증 부족

**위치**:
- `src/app/api/auth/signup/route.ts`
- `src/app/api/auth/signin/route.ts`
- `src/lib/storage/adapters/SupabaseAdapter.ts`

**문제점**:
- 이메일 형식 검증 없음 (정규식, DNS 검증 등)
- name 필드 길이 제한 없음 → 버퍼 오버플로우, 표시 문제
- 특수문자 필터링 없음 → XSS, 주입 공격 가능성
- SupabaseAdapter parseKey에서 디렉토리 탐색 문자 검증 없음

**영향**:
- 잘못된 형식의 데이터 저장
- XSS 공격 가능성
- SQL/NoSQL 주입 가능성
- 시스템 리소스 낭비 (너무 긴 문자열)

**권장 조치**:

```typescript
// 방법 1: Zod 스키마로 전체 입력 검증 (권장)
// src/lib/validation/auth.ts

import { z } from 'zod'
import { passwordSchema } from './password'

export const signupSchema = z.object({
  email: z.string()
    .min(1, '이메일을 입력해주세요.')
    .email('올바른 이메일 형식이 아닙니다.')
    .max(255, '이메일은 255자를 초과할 수 없습니다.')
    .toLowerCase()
    .trim(),

  password: passwordSchema,

  name: z.string()
    .min(2, '이름은 최소 2자 이상이어야 합니다.')
    .max(50, '이름은 50자를 초과할 수 없습니다.')
    .regex(/^[a-zA-Z가-힣\s]+$/, '이름에 특수문자를 사용할 수 없습니다.')
    .trim()
    .transform(name => name.replace(/\s+/g, ' ')), // 중복 공백 제거
})

export const signinSchema = z.object({
  email: z.string()
    .min(1, '이메일을 입력해주세요.')
    .email('올바른 이메일 형식이 아닙니다.')
    .toLowerCase()
    .trim(),

  password: z.string()
    .min(1, '비밀번호를 입력해주세요.'),
})

// src/app/api/auth/signup/route.ts
import { signupSchema } from '@/lib/validation/auth'

export async function POST(request: Request) {
  try {
    const body = await request.json()

    // 입력 검증
    const result = signupSchema.safeParse(body)
    if (!result.success) {
      return NextResponse.json(
        {
          error: result.error.issues[0].message,
          issues: result.error.issues, // 모든 오류 반환
        },
        { status: 400 }
      )
    }

    const { email, password, name } = result.data // 검증된 데이터 사용

    // ... 기존 로직
  } catch (error) {
    // JSON 파싱 오류 처리
    if (error instanceof SyntaxError) {
      return NextResponse.json(
        { error: '잘못된 요청 형식입니다.' },
        { status: 400 }
      )
    }
    throw error
  }
}
```

```typescript
// 방법 2: HTML 태그 및 스크립트 제거 (추가 보안)
// npm install dompurify isomorphic-dompurify

// src/lib/validation/sanitize.ts
import DOMPurify from 'isomorphic-dompurify'

export function sanitizeInput(input: string): string {
  // HTML 태그 완전 제거
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: [], // 모든 태그 제거
    ALLOWED_ATTR: [], // 모든 속성 제거
  }).trim()
}

export function sanitizeObject<T extends Record<string, any>>(obj: T): T {
  const sanitized = {} as T

  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'string') {
      sanitized[key as keyof T] = sanitizeInput(value) as any
    } else {
      sanitized[key as keyof T] = value
    }
  }

  return sanitized
}

// 사용
const sanitized = sanitizeObject({ email, password, name })
```

```typescript
// 방법 3: SupabaseAdapter parseKey 보안 강화
// src/lib/storage/adapters/SupabaseAdapter.ts

private parseKey(key: string): { entity: string; id: string | null; subkey: string | null } {
  // 보안 검증 추가
  if (!key || typeof key !== 'string') {
    throw new StorageError('Invalid key format', 'ADAPTER_ERROR')
  }

  // 디렉토리 탐색 공격 방어
  if (key.includes('..') || key.includes('/') || key.includes('\\')) {
    throw new StorageError(
      'Invalid characters in key',
      'ADAPTER_ERROR',
      { severity: 'high', userMessage: '잘못된 키 형식입니다.' }
    )
  }

  // 길이 제한
  if (key.length > 256) {
    throw new StorageError('Key too long', 'ADAPTER_ERROR')
  }

  const parts = key.split(':')

  // 파트 개수 제한
  if (parts.length > 3) {
    throw new StorageError('Invalid key format', 'ADAPTER_ERROR')
  }

  return {
    entity: parts[0] || '',
    id: parts[1] || null,
    subkey: parts[2] || null,
  }
}
```

---

#### 5. CSRF 보호 불명확

**위치**:
- `src/lib/supabase/middleware.ts:37-43`
- 모든 POST API 엔드포인트

**문제점**:

```typescript
// IMPORTANT: Avoid writing any logic between createServerClient and
// supabase.auth.getUser(). A simple mistake could make your server
// vulnerable to CSRF attacks.
```

- 주석으로만 CSRF 경고, 명시적 보호 메커니즘 없음
- Supabase SSR이 자동으로 CSRF를 방어하는지 불명확
- POST 요청에 Origin/Referer 검증 없음
- CSRF 토큰 생성/검증 로직 없음

**영향**:
- 악성 사이트에서 사용자 세션을 이용한 요청 가능
- 계정 설정 변경, 데이터 생성/수정/삭제 등 위험

**권장 조치**:

```typescript
// 방법 1: Next.js App Router 기본 CSRF 보호 활용 + Origin 검증
// src/middleware.ts

import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  // POST, PUT, DELETE 요청에 대해 Origin 검증
  if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(request.method)) {
    const origin = request.headers.get('origin')
    const host = request.headers.get('host')

    // Origin이 없거나 호스트와 일치하지 않으면 차단
    if (origin && !origin.endsWith(host || '')) {
      console.warn(`[CSRF] Blocked request from ${origin} to ${host}`)
      return new Response('Forbidden: Invalid origin', { status: 403 })
    }
  }

  // Supabase 미들웨어 실행
  return await updateSession(request)
}

export const config = {
  matcher: [
    '/api/:path*',
    '/dashboard/:path*',
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
}
```

```typescript
// 방법 2: CSRF 토큰 라이브러리 사용 (더 강력한 보호)
// npm install csrf

// src/lib/csrf.ts
import { createHash, randomBytes } from 'crypto'

const CSRF_SECRET = process.env.CSRF_SECRET || randomBytes(32).toString('hex')

export function generateCsrfToken(sessionId: string): string {
  const token = randomBytes(32).toString('hex')
  const hash = createHash('sha256')
    .update(`${token}.${sessionId}.${CSRF_SECRET}`)
    .digest('hex')

  return `${token}.${hash}`
}

export function verifyCsrfToken(token: string, sessionId: string): boolean {
  const [tokenPart, hashPart] = token.split('.')

  if (!tokenPart || !hashPart) {
    return false
  }

  const expectedHash = createHash('sha256')
    .update(`${tokenPart}.${sessionId}.${CSRF_SECRET}`)
    .digest('hex')

  return hashPart === expectedHash
}

// API 라우트에서 사용
import { verifyCsrfToken } from '@/lib/csrf'
import { cookies } from 'next/headers'

export async function POST(request: Request) {
  const cookieStore = await cookies()
  const sessionId = cookieStore.get('session-id')?.value

  if (!sessionId) {
    return NextResponse.json({ error: 'No session' }, { status: 401 })
  }

  const csrfToken = request.headers.get('x-csrf-token')

  if (!csrfToken || !verifyCsrfToken(csrfToken, sessionId)) {
    return NextResponse.json({ error: 'Invalid CSRF token' }, { status: 403 })
  }

  // ... 안전한 요청 처리
}
```

```typescript
// 방법 3: SameSite Cookie 설정 (추가 보호)
// Supabase가 자동으로 설정하지만 확인 필요

// src/lib/supabase/middleware.ts
export async function updateSession(request: NextRequest) {
  // ... 기존 코드

  // 쿠키 설정 시 SameSite 옵션 확인
  cookiesToSet.forEach(({ name, value, options }) => {
    supabaseResponse.cookies.set(name, value, {
      ...options,
      sameSite: 'lax', // 또는 'strict'
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
    })
  })

  return supabaseResponse
}
```

---

#### 6. 보안 헤더 미설정

**위치**:
- `next.config.js` (존재 여부 확인 필요)

**문제점**:
- Content-Security-Policy (CSP) 없음 → XSS 공격 방어 부족
- X-Frame-Options 없음 → 클릭재킹 공격 취약
- X-Content-Type-Options 없음 → MIME 스니핑 공격 취약
- Strict-Transport-Security 없음 → HTTPS 강제 없음

**영향**:
- XSS 공격 시 악성 스크립트 실행 가능
- iframe으로 페이지 삽입하여 클릭재킹 공격 가능
- 브라우저 MIME 타입 오판으로 보안 우회 가능

**권장 조치**:

```javascript
// next.config.js (새로 생성 또는 수정)

/** @type {import('next').NextConfig} */
const nextConfig = {
  async headers() {
    return [
      {
        // 모든 경로에 보안 헤더 적용
        source: '/:path*',
        headers: [
          // 클릭재킹 방어
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          // MIME 스니핑 방어
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          // Referer 정책
          {
            key: 'Referrer-Policy',
            value: 'strict-origin-when-cross-origin',
          },
          // 권한 정책
          {
            key: 'Permissions-Policy',
            value: 'camera=(), microphone=(), geolocation=(), payment=()',
          },
          // HTTPS 강제 (프로덕션)
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=63072000; includeSubDomains; preload',
          },
          // XSS 보호
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block',
          },
          // Content Security Policy (XSS 방어)
          {
            key: 'Content-Security-Policy',
            value: [
              "default-src 'self'",
              "script-src 'self' 'unsafe-eval' 'unsafe-inline'", // Next.js 필요
              "style-src 'self' 'unsafe-inline'", // Tailwind 필요
              "img-src 'self' data: https: blob:",
              "font-src 'self' data:",
              "connect-src 'self' https://*.supabase.co wss://*.supabase.co",
              "frame-ancestors 'none'",
              "base-uri 'self'",
              "form-action 'self'",
            ].join('; '),
          },
        ],
      },
    ]
  },

  // 추가 보안 설정
  reactStrictMode: true,
  poweredByHeader: false, // X-Powered-By 헤더 제거
}

module.exports = nextConfig
```

```javascript
// CSP Nonce를 사용한 더 강력한 보호 (선택사항)
// middleware.ts

import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { randomBytes } from 'crypto'

export function middleware(request: NextRequest) {
  const nonce = randomBytes(16).toString('base64')

  const cspHeader = [
    "default-src 'self'",
    `script-src 'self' 'nonce-${nonce}' 'strict-dynamic'`,
    `style-src 'self' 'nonce-${nonce}'`,
    // ... 나머지 CSP
  ].join('; ')

  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-nonce', nonce)
  requestHeaders.set('Content-Security-Policy', cspHeader)

  const response = NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  })

  response.headers.set('Content-Security-Policy', cspHeader)

  return response
}
```

---

### 🟠 Medium (중간) - 중기 조치 권장

#### 7. 세션 타임아웃 정책 미정의

**문제점**:
- 명시적인 세션 타임아웃 설정 없음
- Supabase 기본 설정에 의존 (일반적으로 1시간 access token, 7일 refresh token)
- 장기간 미사용 세션 처리 로직 없음
- "Remember Me" 기능 없음

**권장 조치**:

```typescript
// src/lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      auth: {
        // 자동 토큰 갱신 활성화
        autoRefreshToken: true,
        // 세션 지속성 활성화
        persistSession: true,
        // URL에서 세션 감지
        detectSessionInUrl: true,
        // 세션 만료 시간 설정 (초 단위)
        // 참고: Supabase 서버 설정과 일치해야 함
        flowType: 'pkce',
      },
    }
  )
}
```

```typescript
// 클라이언트에서 비활성 시간 추적
// src/hooks/useInactivityTimeout.ts

import { useEffect } from 'react'
import { useRouter } from 'next/navigation'

const INACTIVITY_TIMEOUT = 30 * 60 * 1000 // 30분

export function useInactivityTimeout() {
  const router = useRouter()

  useEffect(() => {
    let timeoutId: NodeJS.Timeout

    const resetTimer = () => {
      clearTimeout(timeoutId)
      localStorage.setItem('lastActivity', Date.now().toString())

      timeoutId = setTimeout(() => {
        // 30분 비활성 후 자동 로그아웃
        router.push('/api/auth/signout')
      }, INACTIVITY_TIMEOUT)
    }

    // 사용자 활동 감지
    const events = ['mousedown', 'keydown', 'scroll', 'touchstart']
    events.forEach(event => {
      document.addEventListener(event, resetTimer)
    })

    // 초기 타이머 설정
    resetTimer()

    // 페이지 로드 시 마지막 활동 시간 확인
    const lastActivity = localStorage.getItem('lastActivity')
    if (lastActivity) {
      const elapsed = Date.now() - Number(lastActivity)
      if (elapsed > INACTIVITY_TIMEOUT) {
        router.push('/api/auth/signout')
      }
    }

    return () => {
      clearTimeout(timeoutId)
      events.forEach(event => {
        document.removeEventListener(event, resetTimer)
      })
    }
  }, [router])
}

// Layout에서 사용
// src/app/layout.tsx
import { useInactivityTimeout } from '@/hooks/useInactivityTimeout'

export default function RootLayout({ children }: { children: React.ReactNode }) {
  useInactivityTimeout() // 전역에서 활성화

  return (
    <html>
      <body>{children}</body>
    </html>
  )
}
```

---

#### 8. .gitignore 확인 및 비밀 관리

**권장 조치**:

```bash
# .gitignore 확인 및 추가
.env
.env.local
.env.*.local
.env.production
.env.production.local
.env.development.local

# Supabase
.supabase/

# 기타 민감 파일
*.pem
*.key
*.crt
secrets/
```

```bash
# git-secrets 설치 및 설정
# macOS
brew install git-secrets

# 프로젝트에 설치
git secrets --install

# AWS 패턴 등록
git secrets --register-aws

# 커스텀 패턴 추가
git secrets --add 'SUPABASE_.*_KEY'
git secrets --add 'NEXT_PUBLIC_SUPABASE_.*'

# 전체 히스토리 스캔
git secrets --scan-history
```

```bash
# pre-commit hook 추가
# .git/hooks/pre-commit

#!/bin/sh

# .env 파일 커밋 방지
if git diff --cached --name-only | grep -E "\.env(\.|$)"; then
  echo "❌ Error: .env 파일을 커밋하려고 합니다!"
  echo "민감한 정보가 포함되어 있을 수 있습니다."
  exit 1
fi

# API 키 패턴 검색
if git diff --cached | grep -iE "(api[_-]?key|secret[_-]?key|password|token).*=.*['\"][^'\"]{20,}['\"]"; then
  echo "⚠️  Warning: API 키나 비밀번호로 보이는 문자열이 발견되었습니다."
  echo "계속하시겠습니까? (y/n)"
  read -r response
  if [ "$response" != "y" ]; then
    exit 1
  fi
fi

exit 0
```

---

#### 9. XSS 방어 강화

**권장 조치**:

```typescript
// DOMPurify로 사용자 입력 sanitize
// npm install dompurify isomorphic-dompurify
// npm install -D @types/dompurify

// src/lib/sanitize.ts
import DOMPurify from 'isomorphic-dompurify'

export function sanitizeHTML(dirty: string, options?: DOMPurify.Config): string {
  return DOMPurify.sanitize(dirty, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
    ALLOWED_ATTR: ['href', 'title'],
    ALLOW_DATA_ATTR: false,
    ...options,
  })
}

// 사용 예시
// src/components/ProjectDescription.tsx
import { sanitizeHTML } from '@/lib/sanitize'

export function ProjectDescription({ html }: { html: string }) {
  const clean = sanitizeHTML(html)

  return <div dangerouslySetInnerHTML={{ __html: clean }} />
}
```

---

### 🟢 Low (낮음) - 장기 개선 사항

#### 10. 동시 세션 제한

**권장 조치**: 사용자가 동시에 여러 디바이스에서 로그인할 수 있는지 정책 결정 필요. 필요 시 세션 테이블을 추가하여 관리.

---

#### 11. API Key 순환 정책

**권장 조치**:
- Supabase, Gemini, OpenAI 등 API 키를 분기별로 순환
- 키 유출 시 대응 절차 문서화
- 키 만료 알림 시스템 구축

---

#### 12. 의존성 정기 점검

**권장 조치**:

```bash
# 분기별 실행
npm audit
npm audit fix

# 취약점 심각도별 확인
npm audit --production

# 오래된 패키지 확인
npm outdated

# 자동화 (GitHub Actions)
# .github/workflows/security-audit.yml
name: Security Audit
on:
  schedule:
    - cron: '0 0 * * 1' # 매주 월요일
  workflow_dispatch:

jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm audit --audit-level=high
```

---

## ✅ 긍정적 발견 사항

### 1. RLS 정책 우수
- Supabase RLS가 모든 테이블에 적절히 구현됨
- users, projects, clients, documents 등 모든 테이블에서 `auth.uid() = user_id` 확인
- 사용자 데이터 격리가 잘 이루어져 있음

### 2. 인증 시스템 분리
- 서버 컴포넌트용 `createClient()`와 클라이언트 컴포넌트용 `createClient()` 분리
- 쿠키 기반 세션 관리로 XSS 공격 시 토큰 탈취 방어

### 3. 활동 로그
- `activity_logs` 테이블로 사용자 활동 추적 가능
- 감사(audit) 기능으로 보안 사고 조사 지원

### 4. 트랜잭션 지원
- `StorageManager`에서 롤백 가능한 트랜잭션 구현
- 데이터 무결성 보장

---

## 🎯 즉시 실행 체크리스트

### ⏰ 이번 주 내 (Critical)

- [ ] **Rate Limiting 구현**
  - [ ] Upstash Redis + Vercel Edge Middleware 설정
  - [ ] `/api/auth/*` 엔드포인트에 적용 (1분에 5회)
  - [ ] 429 에러 핸들링 구현

- [ ] **프로덕션 로깅 제거**
  - [ ] `google/route.ts`에서 환경 변수 로깅 제거
  - [ ] 환경별 로깅 분기 적용 (`NODE_ENV === 'development'`)
  - [ ] 구조화된 로깅 라이브러리 도입 (pino 등)

- [ ] **.gitignore 확인 및 비밀 스캔**
  - [ ] `.env` 파일이 `.gitignore`에 있는지 확인
  - [ ] `git-secrets` 도구 설치 및 설정
  - [ ] pre-commit hook 추가

---

### 📅 다음 주 (High)

- [ ] **비밀번호 정책 강화**
  - [ ] 최소 10자 이상 + 복잡도 요구사항
  - [ ] Zod 스키마로 검증 구현
  - [ ] 일반적인 비밀번호 차단 리스트 추가

- [ ] **입력 검증 강화**
  - [ ] 이메일, name 등 모든 사용자 입력에 Zod 스키마 적용
  - [ ] SupabaseAdapter `parseKey`에 보안 검증 추가
  - [ ] HTML 태그 sanitize 추가

- [ ] **CSRF 명시적 검증**
  - [ ] Origin 헤더 검증 추가
  - [ ] CSRF 토큰 라이브러리 도입 (선택)
  - [ ] SameSite Cookie 설정 확인

- [ ] **보안 헤더 설정**
  - [ ] `next.config.js`에 보안 헤더 추가
  - [ ] CSP, X-Frame-Options, HSTS 등 설정
  - [ ] 프로덕션 배포 후 헤더 확인

---

### 📆 이번 달 (Medium)

- [ ] **세션 타임아웃 정책**
  - [ ] 비활성 시간 추적 훅 구현
  - [ ] 30분 비활성 후 자동 로그아웃
  - [ ] Supabase 세션 설정 명시

- [ ] **XSS 방어 강화**
  - [ ] DOMPurify 라이브러리 추가
  - [ ] 사용자 입력 HTML sanitize
  - [ ] CSP Nonce 적용 (선택)

- [ ] **보안 감사 로그**
  - [ ] 로그인 실패 이벤트 로깅
  - [ ] 권한 오류 로깅
  - [ ] 보안 관련 이벤트 추적

- [ ] **의존성 점검**
  - [ ] `npm audit` 실행
  - [ ] 취약한 패키지 업데이트
  - [ ] GitHub Actions로 자동화

---

## 📈 기대 효과

### 단기 (1-2주)
- Rate Limiting으로 무차별 대입 공격 방어
- 프로덕션 로깅 제거로 민감 정보 노출 방지
- 보안 점수: **6.5 → 7.5**

### 중기 (1개월)
- 입력 검증 강화로 주입 공격 방어
- 보안 헤더 설정으로 XSS, 클릭재킹 방어
- 비밀번호 정책 강화로 계정 보안 향상
- 보안 점수: **7.5 → 8.5**

### 장기 (3개월)
- 종합적인 보안 체계 구축
- OWASP Top 10 대응 완료
- 보안 점수: **8.5 → 9.5+**

---

## 📚 참고 자료

- [OWASP Top 10 2021](https://owasp.org/Top10/)
- [Supabase Security Best Practices](https://supabase.com/docs/guides/auth/server-side-rendering)
- [Next.js Security Headers](https://nextjs.org/docs/app/api-reference/next-config-js/headers)
- [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)
- [NIST Password Guidelines](https://pages.nist.gov/800-63-3/sp800-63b.html)
- [Content Security Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)

---

## 🔄 다음 점검 일정

- **정기 점검**: 3개월 후 (2026-01-15)
- **의존성 점검**: 매월 1일
- **보안 업데이트**: 즉시 적용

---

**보고서 작성**: Claude (Anthropic)
**분석 방법**: Sequential Thinking + 수동 코드 리뷰
**분석 도구**: Static Analysis, Pattern Matching
**문의**: 추가 구현 지원 필요 시 요청

---

## 🎓 보안 교육 권장 사항

팀원들에게 다음 보안 교육을 권장합니다:

1. **OWASP Top 10** 이해
2. **Secure Coding Practices** 학습
3. **Supabase RLS** 심화 학습
4. **Next.js Security** 모범 사례
5. **암호학 기초** (AES, HMAC, JWT 등)

---

**면책 조항**: 이 보고서는 코드 정적 분석을 기반으로 작성되었으며, 런타임 동적 분석이나 침투 테스트는 포함되지 않았습니다. 실제 운영 환경에서는 전문 보안 업체의 종합 보안 진단을 권장합니다.
