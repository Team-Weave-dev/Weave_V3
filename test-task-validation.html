<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Task Validation Test</title>
  <style>
    body {
      font-family: monospace;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .section {
      margin: 20px 0;
      padding: 15px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .error {
      color: red;
      font-weight: bold;
    }
    .success {
      color: green;
      font-weight: bold;
    }
    pre {
      background: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <h1>Task Validation Diagnostic</h1>
  <div id="output"></div>

  <script>
    const output = document.getElementById('output');

    function addSection(title, content, isError = false) {
      const section = document.createElement('div');
      section.className = 'section';
      section.innerHTML = `
        <h3 class="${isError ? 'error' : 'success'}">${title}</h3>
        <pre>${content}</pre>
      `;
      output.appendChild(section);
    }

    // 1. LocalStorage에서 tasks 가져오기
    const tasksData = localStorage.getItem('weave_v2_tasks');
    if (!tasksData) {
      addSection('Error', 'No tasks found in localStorage', true);
    } else {
      const tasks = JSON.parse(tasksData);
      addSection('Tasks Found', `Total: ${tasks.length} tasks`);

      if (tasks.length > 0) {
        // 2. 첫 번째 task 분석
        const task = tasks[0];
        addSection('First Task', JSON.stringify(task, null, 2));

        // 3. 각 필드 타입 검사
        const fieldReport = [];
        Object.keys(task).forEach(key => {
          const value = task[key];
          const type = typeof value;
          const isNull = value === null;
          const isArray = Array.isArray(value);

          let status = '✓';
          let notes = '';

          // 문제가 될 수 있는 필드 체크
          if (key === 'estimatedHours' || key === 'actualHours') {
            if (value !== null && value !== undefined) {
              if (typeof value !== 'number') {
                status = '✗';
                notes = `Should be number, got ${type}`;
              } else if (value < 0) {
                status = '✗';
                notes = `Negative value: ${value}`;
              }
            }
          }

          if (key === 'subtasks' || key === 'dependencies' || key === 'tags') {
            if (value !== null && value !== undefined) {
              if (!Array.isArray(value)) {
                status = '✗';
                notes = `Should be array, got ${type}`;
              } else if (!value.every(item => typeof item === 'string')) {
                status = '✗';
                notes = `Array contains non-string items`;
              }
            }
          }

          if (key === 'attachments') {
            if (value !== null && value !== undefined) {
              if (!Array.isArray(value)) {
                status = '✗';
                notes = `Should be array, got ${type}`;
              }
            }
          }

          if (key === 'recurring') {
            if (value !== null && value !== undefined) {
              if (typeof value !== 'object') {
                status = '✗';
                notes = `Should be object, got ${type}`;
              } else if (!['daily', 'weekly', 'monthly', 'yearly'].includes(value.pattern)) {
                status = '✗';
                notes = `Invalid pattern: ${value.pattern}`;
              }
            }
          }

          fieldReport.push(`${status} ${key}: ${type}${isNull ? ' (null)' : ''}${isArray ? ' (array)' : ''} ${notes}`);
        });

        addSection('Field Analysis', fieldReport.join('\n'));

        // 4. BaseService.update 시뮬레이션
        const getDeviceId = () => {
          const storedId = localStorage.getItem('weave_device_id');
          if (storedId) return storedId;

          const newId = `device_${Date.now()}_${Math.random().toString(36).substring(7)}`;
          localStorage.setItem('weave_device_id', newId);
          return newId;
        };

        const updatedEntity = {
          ...task,
          ...{ dueDate: new Date().toISOString() },
          id: task.id,
          createdAt: task.createdAt,
          updatedAt: new Date().toISOString(),
          device_id: getDeviceId()
        };

        addSection('Merged Entity (after BaseService.update)', JSON.stringify(updatedEntity, null, 2));

        // 5. isTask 간단 검증
        const errors = [];

        // Required fields
        if (!updatedEntity.id || typeof updatedEntity.id !== 'string') errors.push(`Invalid id: ${updatedEntity.id}`);
        if (!updatedEntity.userId || typeof updatedEntity.userId !== 'string') errors.push(`Invalid userId: ${updatedEntity.userId}`);
        if (!updatedEntity.title || typeof updatedEntity.title !== 'string') errors.push(`Invalid title: ${updatedEntity.title}`);
        if (!['pending', 'in_progress', 'completed', 'cancelled'].includes(updatedEntity.status)) errors.push(`Invalid status: ${updatedEntity.status}`);
        if (!['low', 'medium', 'high', 'urgent'].includes(updatedEntity.priority)) errors.push(`Invalid priority: ${updatedEntity.priority}`);

        // Optional number fields - null과 undefined는 허용
        if (updatedEntity.estimatedHours !== undefined && updatedEntity.estimatedHours !== null) {
          if (typeof updatedEntity.estimatedHours !== 'number' || updatedEntity.estimatedHours < 0) {
            errors.push(`Invalid estimatedHours: ${updatedEntity.estimatedHours} (type: ${typeof updatedEntity.estimatedHours})`);
          }
        }
        if (updatedEntity.actualHours !== undefined && updatedEntity.actualHours !== null) {
          if (typeof updatedEntity.actualHours !== 'number' || updatedEntity.actualHours < 0) {
            errors.push(`Invalid actualHours: ${updatedEntity.actualHours} (type: ${typeof updatedEntity.actualHours})`);
          }
        }

        // Optional array fields - null과 undefined는 허용
        if (updatedEntity.subtasks !== undefined && updatedEntity.subtasks !== null) {
          if (!Array.isArray(updatedEntity.subtasks)) {
            errors.push(`Invalid subtasks: not an array`);
          } else if (!updatedEntity.subtasks.every(item => typeof item === 'string')) {
            errors.push(`Invalid subtasks: not all items are strings`);
          }
        }
        if (updatedEntity.dependencies !== undefined && updatedEntity.dependencies !== null) {
          if (!Array.isArray(updatedEntity.dependencies)) {
            errors.push(`Invalid dependencies: not an array`);
          } else if (!updatedEntity.dependencies.every(item => typeof item === 'string')) {
            errors.push(`Invalid dependencies: not all items are strings`);
          }
        }
        if (updatedEntity.tags !== undefined && updatedEntity.tags !== null) {
          if (!Array.isArray(updatedEntity.tags)) {
            errors.push(`Invalid tags: not an array`);
          } else if (!updatedEntity.tags.every(item => typeof item === 'string')) {
            errors.push(`Invalid tags: not all items are strings`);
          }
        }

        // attachments
        if (updatedEntity.attachments !== undefined && updatedEntity.attachments !== null) {
          if (!Array.isArray(updatedEntity.attachments)) {
            errors.push(`Invalid attachments: not an array`);
          }
        }

        // recurring
        if (updatedEntity.recurring !== undefined && updatedEntity.recurring !== null) {
          if (typeof updatedEntity.recurring !== 'object') {
            errors.push(`Invalid recurring: not an object`);
          } else if (!['daily', 'weekly', 'monthly', 'yearly'].includes(updatedEntity.recurring.pattern)) {
            errors.push(`Invalid recurring.pattern: ${updatedEntity.recurring.pattern}`);
          }
        }

        if (errors.length === 0) {
          addSection('Validation Result', '✅ All validation checks PASSED!');
        } else {
          addSection('Validation Result', '❌ Validation FAILED:\n\n' + errors.join('\n'), true);
        }
      }
    }
  </script>
</body>
</html>
